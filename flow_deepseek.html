<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>* { margin: 0; padding: 0; } body { background: #0a0a14; overflow: hidden; } canvas { display: block; }</style>
</head>
<body>
<canvas id="flowCanvas" width="500" height="670"></canvas>

<script>
const canvas = document.getElementById('flowCanvas');
const ctx = canvas.getContext('2d');

// Fixed seed for reproducibility
const SEED = 42;
const PARTICLE_COUNT = 2000;
const RESTART_INTERVAL = 10000; // 10 seconds

// Canvas dimensions
const WIDTH = 500;
const HEIGHT = 670;

// Particle system
let particles = [];
let startTime = Date.now();
let restartTime = startTime;

// Deterministic pseudo-random number generator (LCG)
class PRNG {
  constructor(seed) {
    this.seed = seed % 2147483647;
    if (this.seed <= 0) this.seed += 2147483646;
  }
  
  next() {
    this.seed = (this.seed * 16807) % 2147483647;
    return (this.seed - 1) / 2147483646;
  }
}

const prng = new PRNG(SEED);

// Deterministic gradient noise (simplified Perlin-like)
class Noise {
  constructor(seed) {
    this.gradients = [];
    this.prng = new PRNG(seed);
    
    // Precompute gradient vectors
    for (let i = 0; i < 256; i++) {
      const angle = this.prng.next() * Math.PI * 2;
      this.gradients[i] = [Math.cos(angle), Math.sin(angle)];
    }
    
    // Permutation table
    this.perm = new Array(512);
    for (let i = 0; i < 256; i++) this.perm[i] = i;
    
    // Fisher-Yates shuffle using deterministic PRNG
    for (let i = 255; i > 0; i--) {
      const j = Math.floor(this.prng.next() * (i + 1));
      [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
    }
    
    // Duplicate permutation table
    for (let i = 0; i < 256; i++) {
      this.perm[i + 256] = this.perm[i];
    }
  }
  
  fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }
  
  lerp(a, b, t) {
    return a + t * (b - a);
  }
  
  grad(hash, x, y) {
    const g = this.gradients[hash % 256];
    return g[0] * x + g[1] * y;
  }
  
  noise2D(x, y) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    
    x -= Math.floor(x);
    y -= Math.floor(y);
    
    const u = this.fade(x);
    const v = this.fade(y);
    
    const aa = this.perm[this.perm[X] + Y];
    const ab = this.perm[this.perm[X] + Y + 1];
    const ba = this.perm[this.perm[X + 1] + Y];
    const bb = this.perm[this.perm[X + 1] + Y + 1];
    
    return this.lerp(
      this.lerp(this.grad(aa, x, y), this.grad(ba, x - 1, y), u),
      this.lerp(this.grad(ab, x, y - 1), this.grad(bb, x - 1, y - 1), u),
      v
    );
  }
  
  // Curl noise implementation for divergence-free field
  curlNoise(x, y, t) {
    const eps = 0.01;
    
    // Sample noise at offset positions
    const n1 = this.noise2D(x + eps, y, t);
    const n2 = this.noise2D(x - eps, y, t);
    const n3 = this.noise2D(x, y + eps, t);
    const n4 = this.noise2D(x, y - eps, t);
    
    // Calculate derivatives (curl in 2D)
    const dx = (n1 - n2) / (2 * eps);
    const dy = (n3 - n4) / (2 * eps);
    
    // Return rotated gradient (curl)
    return [-dy, dx];
  }
  
  // Time-varying curl noise
  getFlowVector(x, y, time) {
    const scale = 0.005;
    const timeScale = 0.0005;
    const curlScale = 0.8;
    
    // Base noise with time variation
    const baseX = x * scale;
    const baseY = y * scale;
    const baseT = time * timeScale;
    
    // Get curl vector
    let [vx, vy] = this.curlNoise(baseX, baseY, baseT);
    
    // Add additional time-varying curl component
    const curlX = this.noise2D(baseX * 1.3 + 100, baseY * 1.3, baseT * 1.5) * 0.3;
    const curlY = this.noise2D(baseX * 1.3, baseY * 1.3 + 100, baseT * 1.5) * 0.3;
    
    vx = vx * curlScale + curlX;
    vy = vy * curlScale + curlY;
    
    // Normalize to constant speed
    const speed = 2.5;
    const mag = Math.sqrt(vx * vx + vy * vy);
    
    if (mag > 0) {
      vx = (vx / mag) * speed;
      vy = (vy / mag) * speed;
    }
    
    return [vx, vy];
  }
}

// Initialize noise generator
const noise = new Noise(SEED);

// Particle class
class Particle {
  constructor() {
    this.reset();
    this.x = this.startX;
    this.y = this.startY;
    this.history = [];
    this.maxHistory = 20;
  }
  
  reset() {
    this.startX = prng.next() * WIDTH;
    this.startY = prng.next() * HEIGHT;
    this.x = this.startX;
    this.y = this.startY;
    this.history = [];
    this.age = 0;
    this.hue = prng.next() * 60 + 180; // Blue-cyan range
  }
  
  update(time) {
    // Add to history for trail
    this.history.push([this.x, this.y]);
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }
    
    // Get flow vector at current position
    const [vx, vy] = noise.getFlowVector(this.x, this.y, time);
    
    // Update position
    this.x += vx;
    this.y += vy;
    this.age++;
    
    // Wrap around edges
    if (this.x < 0) this.x += WIDTH;
    if (this.x > WIDTH) this.x -= WIDTH;
    if (this.y < 0) this.y += HEIGHT;
    if (this.y > HEIGHT) this.y -= HEIGHT;
  }
  
  draw(ctx) {
    if (this.history.length < 2) return;
    
    // Draw trail
    ctx.beginPath();
    ctx.moveTo(this.history[0][0], this.history[0][1]);
    
    for (let i = 1; i < this.history.length; i++) {
      const alpha = i / this.history.length;
      const [x, y] = this.history[i];
      
      ctx.lineTo(x, y);
      ctx.strokeStyle = `hsla(${this.hue}, 70%, 60%, ${alpha * 0.6})`;
      ctx.lineWidth = 1.5;
      ctx.stroke();
      
      // Start new path for gradient opacity
      ctx.beginPath();
      ctx.moveTo(x, y);
    }
    
    // Draw particle head
    ctx.beginPath();
    ctx.arc(this.x, this.y, 1.2, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${this.hue}, 100%, 80%, 0.8)`;
    ctx.fill();
  }
}

// Initialize particles
function initParticles() {
  particles = [];
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    particles.push(new Particle());
  }
}

// Animation loop
function animate() {
  const currentTime = Date.now();
  const elapsed = currentTime - startTime;
  const time = elapsed / 1000;
  
  // Check for restart
  if (currentTime - restartTime >= RESTART_INTERVAL) {
    initParticles();
    restartTime = currentTime;
  }
  
  // Fade effect
  ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
  ctx.fillRect(0, 0, WIDTH, HEIGHT);
  
  // Update and draw particles
  for (const particle of particles) {
    particle.update(time);
    particle.draw(ctx);
  }
  
  requestAnimationFrame(animate);
}

// Initialize and start
initParticles();
animate();
</script>
</body>
</html>