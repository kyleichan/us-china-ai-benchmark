<!DOCTYPE html>
<html>
<head>
<style>
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #000;
        overflow: hidden;
    }
    canvas {
        background-color: #000;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
</style>
</head>
<body>
<canvas id="c" width="500" height="670"></canvas>
<script>
/**
 * Deterministic Flow Field Visualization
 * 
 * Features:
 * - Custom seeded PRNG (Mulberry32) for determinism.
 * - 3D Perlin Noise implementation from scratch.
 * - Curl Noise derivation (Finite Difference) to prevent sinks.
 * - Normalized velocity vectors for constant speed.
 * - 10-second loop cycle.
 */

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });
const width = 500;
const height = 670;

// Configuration
const PARTICLE_COUNT = 2000;
const NOISE_SCALE = 0.003; // Zoom level of the field
const TIME_SCALE = 0.0001; // Speed of field evolution
const PARTICLE_SPEED = 2.0;
const TRAIL_FADE = 0.08; // Lower = longer trails
const SEED_INT = 8675309; 

// --- 1. Deterministic Random (Mulberry32) ---
let seedState = SEED_INT;

function setSeed(s) {
    seedState = s;
}

function random() {
    let t = seedState += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
}

// --- 2. Perlin Noise Implementation ---
// A standard implementation of 3D gradient noise.

const PERM = new Uint8Array(512);
const GRAD3 = [
    [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
    [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
    [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
];

function initNoise() {
    const p = new Uint8Array(256);
    for (let i = 0; i < 256; i++) p[i] = i;
    
    // Shuffle using our deterministic random
    for (let i = 255; i > 0; i--) {
        const r = Math.floor(random() * (i + 1));
        const temp = p[i];
        p[i] = p[r];
        p[r] = temp;
    }

    // Duplicate for wrapping
    for (let i = 0; i < 512; i++) {
        PERM[i] = p[i & 255];
    }
}

function dot(g, x, y, z) {
    return g[0]*x + g[1]*y + g[2]*z;
}

function mix(a, b, t) {
    return (1 - t) * a + t * b;
}

function fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
}

function noise3D(x, y, z) {
    let X = Math.floor(x) & 255;
    let Y = Math.floor(y) & 255;
    let Z = Math.floor(z) & 255;

    x -= Math.floor(x);
    y -= Math.floor(y);
    z -= Math.floor(z);

    const u = fade(x);
    const v = fade(y);
    const w = fade(z);

    const A = PERM[X] + Y, AA = PERM[A] + Z, AB = PERM[A+1] + Z;
    const B = PERM[X+1] + Y, BA = PERM[B] + Z, BB = PERM[B+1] + Z;

    return mix(
        mix(mix(dot(GRAD3[PERM[AA] % 12], x, y, z),
                dot(GRAD3[PERM[BA] % 12], x-1, y, z), u),
            mix(dot(GRAD3[PERM[AB] % 12], x, y-1, z),
                dot(GRAD3[PERM[BB] % 12], x-1, y-1, z), u), v),
        mix(mix(dot(GRAD3[PERM[AA+1] % 12], x, y, z-1),
                dot(GRAD3[PERM[BA+1] % 12], x-1, y, z-1), u),
            mix(dot(GRAD3[PERM[AB+1] % 12], x, y-1, z-1),
                dot(GRAD3[PERM[BB+1] % 12], x-1, y-1, z-1), u), v), w);
}

// --- 3. Curl Noise Helper ---
// Curl noise is the derivative of the potential field. 
// For 2D flow, we take a 3D noise slice and approximate:
// vx = d(noise)/dy, vy = -d(noise)/dx
const EPSILON = 0.001; // Tiny offset for finite difference

function getCurlVelocity(x, y, t) {
    // We sample noise at offsets to approximate the partial derivatives
    const n1 = noise3D(x, y + EPSILON, t);
    const n2 = noise3D(x, y - EPSILON, t);
    const n3 = noise3D(x + EPSILON, y, t);
    const n4 = noise3D(x - EPSILON, y, t);

    // Differentiate
    const dx = (n1 - n2) / (2 * EPSILON); // d/dy
    const dy = (n3 - n4) / (2 * EPSILON); // d/dx

    // Curl vector (d/dy, -d/dx)
    let vx = dx;
    let vy = -dy;

    // Normalize to ensure constant speed
    const mag = Math.sqrt(vx * vx + vy * vy) || 0.001; // Avoid div by zero
    
    return {
        x: (vx / mag) * PARTICLE_SPEED,
        y: (vy / mag) * PARTICLE_SPEED
    };
}

// --- 4. Particle System ---

let particles = [];

function initParticles() {
    particles = [];
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        particles.push({
            x: random() * width,
            y: random() * height,
            color: `hsla(${Math.floor(random() * 40 + 180)}, 80%, 60%, 0.8)` // Cyan/Blue tones
        });
    }
}

// --- 5. Main Loop ---

let animationId;
let startTime = 0;
let lastReset = 0;
const DURATION = 10000; // 10 seconds

function reset() {
    setSeed(SEED_INT);
    initNoise();
    initParticles();
    
    // Clear canvas completely on reset
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, width, height);
}

function animate(timestamp) {
    if (!startTime) startTime = timestamp;
    
    // Check for 10s restart
    if (timestamp - lastReset > DURATION) {
        lastReset = timestamp;
        reset();
    }

    // "Fade" effect: Draw a semi-transparent black rect over everything
    // This creates the trails.
    ctx.fillStyle = `rgba(0, 0, 0, ${TRAIL_FADE})`;
    ctx.fillRect(0, 0, width, height);

    // Calculate time offset for the noise field (slow evolution)
    // We base this on the time within the current 10s loop for consistency
    const loopTime = timestamp - lastReset;
    const zOff = loopTime * TIME_SCALE; 

    // Draw Particles
    // We batch draw calls slightly by setting fill style once
    // but individual colors require state changes.
    // For performance with 2000 particles, simple rects are fine.
    
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const p = particles[i];
        
        // Calculate velocity
        // Scale coords down for noise lookup
        const v = getCurlVelocity(p.x * NOISE_SCALE, p.y * NOISE_SCALE, zOff);
        
        p.x += v.x;
        p.y += v.y;

        // Wrap edges
        if (p.x < 0) p.x += width;
        if (p.x > width) p.x -= width;
        if (p.y < 0) p.y += height;
        if (p.y > height) p.y -= height;

        // Draw
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 1.5, 1.5);
    }

    animationId = requestAnimationFrame(animate);
}

// Start
reset();
lastReset = performance.now(); // Sync start
requestAnimationFrame(animate);

</script>
</body>
</html>