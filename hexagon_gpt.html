<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<style>
html,body{margin:0;padding:0;width:100%;height:100%;display:flex;justify-content:center;align-items:center;background:#000}
canvas{display:block}
</style>
</head>
<body>
<canvas id="c" width="500" height="670"></canvas>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;

  // Deterministic-ish RNG per reset
  function mulberry32(seed){
    return function(){
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  const TWO_PI = Math.PI * 2;

  // Physics/World
  const gravity = 900;           // px/s^2
  const airDamp = 0.08;          // per second
  const restitution = 0.62;      // bounce
  const wallFriction = 0.22;     // tangential loss on collision
  const substeps = 3;

  // Hex setup
  const hexes = [
    {R: 210, w: 5, gapSide: 0, ang0: 0.0, spin:  0.55, color: 'rgba(255,255,255,0.9)'},
    {R: 150, w: 5, gapSide: 2, ang0: 0.0, spin: -0.85, color: 'rgba(255,255,255,0.8)'},
    {R:  95, w: 5, gapSide: 4, ang0: 0.0, spin:  1.15, color: 'rgba(255,255,255,0.75)'}
  ];

  // Precompute local vertices for a pointy-top regular hex (one vertex at angle 0)
  function hexVertsLocal(R){
    const verts = [];
    for (let i=0;i<6;i++){
      const a = i * (Math.PI/3);
      verts.push({x: Math.cos(a)*R, y: Math.sin(a)*R});
    }
    return verts;
  }
  const localVerts = new Map();
  function getLocalVerts(R){
    if(!localVerts.has(R)) localVerts.set(R, hexVertsLocal(R));
    return localVerts.get(R);
  }

  function rot(p, a){
    const ca = Math.cos(a), sa = Math.sin(a);
    return {x: p.x*ca - p.y*sa, y: p.x*sa + p.y*ca};
  }

  function clamp(v, lo, hi){ return v<lo?lo:(v>hi?hi:v); }

  // Segment distance and closest point
  function closestPointOnSegment(px, py, ax, ay, bx, by){
    const abx = bx-ax, aby = by-ay;
    const apx = px-ax, apy = py-ay;
    const ab2 = abx*abx + aby*aby;
    let t = ab2 > 0 ? (apx*abx + apy*aby)/ab2 : 0;
    t = clamp(t, 0, 1);
    return {x: ax + abx*t, y: ay + aby*t, t};
  }

  // Build edges (segments) for each hex at current angle, excluding one side
  function buildHexEdges(hex, angle){
    const verts = getLocalVerts(hex.R);
    const world = verts.map(v => {
      const r = rot(v, angle);
      return {x: cx + r.x, y: cy + r.y};
    });
    const edges = [];
    for (let i=0;i<6;i++){
      if (i === hex.gapSide) continue;
      const a = world[i];
      const b = world[(i+1)%6];
      // Ensure normal points inward (toward center) by orienting edge CCW about center.
      // Since vertices are generated CCW, edge direction is CCW; inward normal is left-normal.
      const ex = b.x - a.x, ey = b.y - a.y;
      let nx = -ey, ny = ex;
      const nl = Math.hypot(nx, ny) || 1;
      nx /= nl; ny /= nl;

      // Verify inward (dot from edge midpoint to center should align with normal)
      const mx = (a.x+b.x)*0.5, my = (a.y+b.y)*0.5;
      const toC = {x: cx-mx, y: cy-my};
      if (toC.x*nx + toC.y*ny < 0){ nx = -nx; ny = -ny; }

      edges.push({ax:a.x, ay:a.y, bx:b.x, by:b.y, nx, ny});
    }
    return {world, edges};
  }

  // Balls
  let balls = [];
  let rng = mulberry32(123456);

  function reset(seed){
    rng = mulberry32(seed);
    balls = [];

    const n = 18;
    for (let i=0;i<n;i++){
      const r = 4 + rng()*3.5;
      const angle = rng()*TWO_PI;
      const speed = 60 + rng()*120;
      // Start very near center, slightly dispersed
      const rr = (rng()*6);
      const px = cx + Math.cos(angle)*rr;
      const py = cy + Math.sin(angle)*rr;

      const vx = Math.cos(angle + (rng()-0.5)*0.9) * speed;
      const vy = Math.sin(angle + (rng()-0.5)*0.9) * speed - 40;

      const hue = 180 + rng()*160;
      balls.push({
        x:px, y:py, vx, vy, r,
        alive:true,
        col:`hsl(${hue},90%,60%)`
      });
    }

    // give hexes phase offsets each restart
    hexes[0].ang0 = rng()*TWO_PI;
    hexes[1].ang0 = rng()*TWO_PI;
    hexes[2].ang0 = rng()*TWO_PI;
  }

  // Collision solve with one edge segment (with thickness)
  function collideBallWithEdge(ball, edge, thickness){
    // Expand segment to include "wall thickness" as a capsule, approximate by distance to segment line;
    // Use closest point on segment + resolve if within radius+thickness/2
    const cp = closestPointOnSegment(ball.x, ball.y, edge.ax, edge.ay, edge.bx, edge.by);
    const dx = ball.x - cp.x, dy = ball.y - cp.y;
    const dist = Math.hypot(dx, dy) || 1e-9;
    const target = ball.r + thickness*0.5;

    if (dist < target){
      // Move out along inward normal if possible; otherwise use radial from closest point
      // Prefer the segment's inward normal for stable bounce.
      let nx = edge.nx, ny = edge.ny;

      // Ensure normal points from wall toward ball for resolution
      // If ball is "outside" relative to inward normal, flip
      const rel = (ball.x - cp.x)*nx + (ball.y - cp.y)*ny;
      if (rel < 0){ nx = -nx; ny = -ny; }

      const pen = (target - dist);
      // Position correction
      ball.x += nx * (pen + 0.01);
      ball.y += ny * (pen + 0.01);

      // Velocity response: split into normal/tangent components
      const vn = ball.vx*nx + ball.vy*ny;
      const tx = -ny, ty = nx;
      const vt = ball.vx*tx + ball.vy*ty;

      // Only bounce if moving into wall
      if (vn < 0){
        const newVn = -vn * restitution;
        const newVt = vt * (1 - wallFriction);

        ball.vx = newVn*nx + newVt*tx;
        ball.vy = newVn*ny + newVt*ty;
      } else {
        // Still apply tangential friction if rubbing
        const newVt = vt * (1 - wallFriction*0.35);
        ball.vx = vn*nx + newVt*tx;
        ball.vy = vn*ny + newVt*ty;
      }
      return true;
    }
    return false;
  }

  // Ball-ball collisions for extra "bouncy"
  function collideBalls(){
    for (let i=0;i<balls.length;i++){
      const a = balls[i]; if(!a.alive) continue;
      for (let j=i+1;j<balls.length;j++){
        const b = balls[j]; if(!b.alive) continue;
        const dx = b.x-a.x, dy = b.y-a.y;
        const dist = Math.hypot(dx,dy) || 1e-9;
        const minD = a.r + b.r;
        if (dist < minD){
          const nx = dx/dist, ny = dy/dist;
          const pen = (minD - dist);
          // Separate equally
          a.x -= nx * pen*0.5;
          a.y -= ny * pen*0.5;
          b.x += nx * pen*0.5;
          b.y += ny * pen*0.5;

          // Relative velocity along normal
          const rvx = b.vx - a.vx, rvy = b.vy - a.vy;
          const vn = rvx*nx + rvy*ny;
          if (vn < 0){
            const e = 0.68;
            const jimp = -(1+e)*vn / 2; // equal mass
            const ix = jimp*nx, iy = jimp*ny;
            a.vx -= ix; a.vy -= iy;
            b.vx += ix; b.vy += iy;

            // small tangential friction
            const tx = -ny, ty = nx;
            const vt = rvx*tx + rvy*ty;
            const jt = -vt * 0.08;
            const itx = jt*tx, ity = jt*ty;
            a.vx -= itx; a.vy -= ity;
            b.vx += itx; b.vy += ity;
          }
        }
      }
    }
  }

  function drawHex(hex, angle){
    const verts = getLocalVerts(hex.R).map(v => {
      const r = rot(v, angle);
      return {x: cx + r.x, y: cy + r.y};
    });

    ctx.strokeStyle = hex.color;
    ctx.lineWidth = hex.w;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    // Draw all sides except the missing one
    ctx.beginPath();
    for (let i=0;i<6;i++){
      if (i === hex.gapSide) continue;
      const a = verts[i];
      const b = verts[(i+1)%6];
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
    }
    ctx.stroke();
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // subtle vignette
    const g = ctx.createRadialGradient(cx,cy,40,cx,cy,420);
    g.addColorStop(0,'rgba(0,0,0,0)');
    g.addColorStop(1,'rgba(0,0,0,0.65)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // hexes
    for (let i=0;i<hexes.length;i++){
      const hex = hexes[i];
      const ang = hex.ang0 + t*hex.spin;
      drawHex(hex, ang);
    }

    // balls
    for (const b of balls){
      if(!b.alive) continue;
      ctx.beginPath();
      ctx.fillStyle = b.col;
      ctx.arc(b.x, b.y, b.r, 0, TWO_PI);
      ctx.fill();
    }
  }

  let last = performance.now();
  let t = 0;

  function step(now){
    const dt0 = Math.min(0.033, (now - last)/1000);
    last = now;

    // restart every 10 seconds
    if (t + dt0 >= 10){
      reset((now|0) ^ 0xA53C19);
      t = 0;
    } else {
      t += dt0;
    }

    // Precompute hex edges per substep (since they rotate; update each substep for stability)
    const dt = dt0 / substeps;

    for (let s=0;s<substeps;s++){
      const time = t + s*dt;

      const built = hexes.map(h => buildHexEdges(h, h.ang0 + time*h.spin));

      // Integrate balls
      for (const b of balls){
        if(!b.alive) continue;

        // forces
        b.vy += gravity * dt;

        // air drag (exponential)
        const damp = Math.exp(-airDamp * dt);
        b.vx *= damp;
        b.vy *= damp;

        // integrate
        b.x += b.vx * dt;
        b.y += b.vy * dt;

        // collide against all hex edges
        for (let i=0;i<built.length;i++){
          const thickness = hexes[i].w;
          const edges = built[i].edges;
          // multiple iterations can help for corners
          for (let k=0;k<2;k++){
            let hit = false;
            for (const e of edges){
              hit = collideBallWithEdge(b, e, thickness) || hit;
            }
            if(!hit) break;
          }
        }

        // If far outside, mark dead
        const dx = b.x - cx, dy = b.y - cy;
        if (dx*dx + dy*dy > (Math.max(...hexes.map(h=>h.R)) + 120) ** 2) b.alive = false;

        // Also cull if fully off-canvas
        if (b.x < -80 || b.x > W+80 || b.y < -80 || b.y > H+80) b.alive = false;
      }

      // Ball-ball collisions
      collideBalls();
    }

    draw();
    requestAnimationFrame(step);
  }

  reset(123456);
  requestAnimationFrame(step);
})();
</script>
</body>
</html>