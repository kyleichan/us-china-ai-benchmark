<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=250, height=400, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Nested Hexagons + Balls</title>
<style>
  html,body{margin:0;padding:0;background:#0b0f17;overflow:hidden;}
  canvas{display:block;margin:0 auto;background:#0b0f17;}
</style>
</head>
<body>
<canvas id="c" width="250" height="400"></canvas>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const W = canvas.width, H = canvas.height;
  const cx = W * 0.5, cy = H * 0.5;

  // ---------- Utils ----------
  const TAU = Math.PI * 2;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const hypot = Math.hypot;

  function rotatePoint(x, y, a) {
    const c = Math.cos(a), s = Math.sin(a);
    return { x: x * c - y * s, y: x * s + y * c };
  }

  function segmentClosestPoint(ax, ay, bx, by, px, py) {
    const abx = bx - ax, aby = by - ay;
    const apx = px - ax, apy = py - ay;
    const ab2 = abx * abx + aby * aby || 1e-9;
    let t = (apx * abx + apy * aby) / ab2;
    t = clamp(t, 0, 1);
    return { x: ax + abx * t, y: ay + aby * t, t };
  }

  function pointInConvexPoly(px, py, verts) {
    // Works for CCW convex polygon.
    let sign = 0;
    for (let i = 0; i < verts.length; i++) {
      const a = verts[i], b = verts[(i + 1) % verts.length];
      const cross = (b.x - a.x) * (py - a.y) - (b.y - a.y) * (px - a.x);
      if (cross === 0) continue;
      const s = cross > 0 ? 1 : -1;
      if (sign === 0) sign = s;
      else if (sign !== s) return false;
    }
    return true;
  }

  // ---------- Hex ring definition ----------
  class OpenHex {
    constructor(radius, angle, angVel, missingSideIndex, color, thickness) {
      this.r = radius;
      this.a = angle;
      this.w = angVel;
      this.miss = missingSideIndex; // 0..5
      this.color = color;
      this.th = thickness;
      this.verts = new Array(6);
      this.sides = []; // {ax,ay,bx,by,nx,ny}
      this.updateGeom();
    }
    update(dt) {
      this.a += this.w * dt;
      this.updateGeom();
    }
    updateGeom() {
      // CCW vertices, rotated by this.a
      for (let i = 0; i < 6; i++) {
        const ang = this.a + i * (TAU / 6);
        this.verts[i] = { x: cx + Math.cos(ang) * this.r, y: cy + Math.sin(ang) * this.r };
      }
      this.sides.length = 0;
      for (let i = 0; i < 6; i++) {
        if (i === this.miss) continue; // skip missing side
        const A = this.verts[i];
        const B = this.verts[(i + 1) % 6];
        // For CCW polygon, inward normal is left of edge direction (B-A)
        const dx = B.x - A.x, dy = B.y - A.y;
        const len = Math.hypot(dx, dy) || 1e-9;
        const nx = -dy / len, ny = dx / len; // inward
        this.sides.push({ ax: A.x, ay: A.y, bx: B.x, by: B.y, nx, ny });
      }
    }
    draw(ctx) {
      ctx.save();
      ctx.lineWidth = this.th;
      ctx.strokeStyle = this.color;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      for (let i = 0; i < 6; i++) {
        if (i === this.miss) continue;
        const A = this.verts[i];
        const B = this.verts[(i + 1) % 6];
        ctx.beginPath();
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  // ---------- Ball physics ----------
  const balls = [];
  let spawnAcc = 0;

  const params = {
    gravity: 900,            // px/s^2
    airDrag: 0.12,           // per second (approx)
    restitution: 0.72,       // bounciness
    frictionTangent: 0.20,   // tangential damping on contact
    spinCoupling: 0.02,      // couple wall motion into ball a bit (helps feel "real")
    substeps: 3
  };

  function spawnBall() {
    const r = rand(3.2, 5.2);
    const speed = rand(10, 40);
    const ang = rand(0, TAU);
    balls.push({
      x: cx + rand(-2, 2),
      y: cy + rand(-2, 2),
      vx: Math.cos(ang) * speed,
      vy: Math.sin(ang) * speed,
      r,
      hue: rand(180, 320),
      life: 0
    });
  }

  // ---------- Scene: 3 nested open hexagons ----------
  const hexes = [
    new OpenHex(140, 0.2,  0.55, 1, "rgba(120,200,255,0.95)", 5),
    new OpenHex( 98, -0.5, -0.85, 4, "rgba(180,255,190,0.90)", 5),
    new OpenHex( 58, 0.9,  1.35, 2, "rgba(255,180,220,0.92)", 5),
  ];

  // Central "start area" is inside all rings.
  function insideAllHexes(x, y) {
    for (const h of hexes) {
      if (!pointInConvexPoly(x, y, h.verts)) return false;
    }
    return true;
  }

  function resolveBallAgainstHex(ball, hex, dt) {
    // Only enforce collisions if ball is inside that hex's polygon (as if walls are boundaries);
    // if outside, we do nothing (ball already escaped that ring).
    if (!pointInConvexPoly(ball.x, ball.y, hex.verts)) return;

    // collide with existing sides (excluding missing one)
    let collided = false;
    for (const s of hex.sides) {
      // Signed distance to supporting line (positive means inside for our inward normal)
      const dist = (ball.x - s.ax) * s.nx + (ball.y - s.ay) * s.ny;

      // If dist < r, penetration outside (or near boundary) => correct
      if (dist < ball.r) {
        // Ensure closest point lies on segment; otherwise ignore (avoid corner glitches)
        const cp = segmentClosestPoint(s.ax, s.ay, s.bx, s.by, ball.x, ball.y);
        const dx = ball.x - cp.x, dy = ball.y - cp.y;
        const d2 = dx*dx + dy*dy;
        if (d2 > (ball.r * ball.r * 1.35)) continue;

        const pen = (ball.r - dist);
        // Positional correction back inside
        ball.x += s.nx * pen;
        ball.y += s.ny * pen;

        // Approx wall velocity due to rotation about center at this contact point:
        // v_wall = omega x r  (2D: (-w*ry, w*rx))
        const rx = cp.x - cx, ry = cp.y - cy;
        const vwx = -hex.w * ry;
        const vwy =  hex.w * rx;

        // Relative velocity
        const rvx = ball.vx - vwx;
        const rvy = ball.vy - vwy;

        // Normal component
        const vn = rvx * s.nx + rvy * s.ny;
        if (vn < 0) {
          // Reflect with restitution
          const jn = -(1 + params.restitution) * vn;
          ball.vx += jn * s.nx;
          ball.vy += jn * s.ny;

          // Tangential friction
          const tx = -s.ny, ty = s.nx;
          const vt = (rvx * tx + rvy * ty);
          const jt = -vt * params.frictionTangent;
          ball.vx += jt * tx;
          ball.vy += jt * ty;

          // Couple a bit of wall motion (feel of spinning enclosure)
          ball.vx += (vwx - ball.vx) * params.spinCoupling;
          ball.vy += (vwy - ball.vy) * params.spinCoupling;
        }
        collided = true;
      }
    }
    return collided;
  }

  // ---------- Render ----------
  function drawBall(b) {
    ctx.beginPath();
    ctx.fillStyle = `hsl(${b.hue} 90% 65%)`;
    ctx.arc(b.x, b.y, b.r, 0, TAU);
    ctx.fill();
  }

  function drawBackground() {
    // subtle vignette
    ctx.fillStyle = "#0b0f17";
    ctx.fillRect(0, 0, W, H);

    const grd = ctx.createRadialGradient(cx, cy, 20, cx, cy, 220);
    grd.addColorStop(0, "rgba(255,255,255,0.05)");
    grd.addColorStop(1, "rgba(0,0,0,0.65)");
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, W, H);
  }

  // ---------- Main loop ----------
  let last = performance.now();
  function frame(now) {
    const dt0 = clamp((now - last) / 1000, 0, 1/20);
    last = now;

    // Spawn new balls continuously, from center
    spawnAcc += dt0 * 12; // balls/sec
    while (spawnAcc >= 1) {
      spawnAcc -= 1;
      spawnBall();
    }

    // Update hexes
    for (const h of hexes) h.update(dt0);

    // Physics substeps for stability
    const steps = params.substeps;
    const dt = dt0 / steps;

    for (let si = 0; si < steps; si++) {
      for (let i = balls.length - 1; i >= 0; i--) {
        const b = balls[i];
        b.life += dt;

        // Forces
        b.vy += params.gravity * dt;

        // Air drag (approx exponential)
        const drag = Math.max(0, 1 - params.airDrag * dt);
        b.vx *= drag;
        b.vy *= drag;

        // Integrate
        b.x += b.vx * dt;
        b.y += b.vy * dt;

        // Collide against each hex boundary
        for (const h of hexes) resolveBallAgainstHex(b, h, dt);

        // Remove if clearly outside the frame (escaped)
        if (b.x < -30 || b.x > W + 30 || b.y < -60 || b.y > H + 60 || b.life > 30) {
          balls.splice(i, 1);
        }
      }
    }

    // Draw
    drawBackground();

    // Hexes behind balls? We'll draw hexes then balls then a light overlay.
    for (const h of hexes) h.draw(ctx);
    for (const b of balls) drawBall(b);

    // soft glow at center
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    const g2 = ctx.createRadialGradient(cx, cy, 0, cx, cy, 80);
    g2.addColorStop(0, "rgba(255,255,255,0.10)");
    g2.addColorStop(1, "rgba(255,255,255,0.00)");
    ctx.fillStyle = g2;
    ctx.fillRect(0, 0, W, H);
    ctx.restore();

    requestAnimationFrame(frame);
  }

  // Seed a few balls
  for (let i = 0; i < 10; i++) spawnBall();

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>