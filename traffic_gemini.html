<!DOCTYPE html>
<html>
<head>
<style>
    body { margin: 0; background: #111; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
    canvas { background: #222; box-shadow: 0 0 20px #000; }
</style>
</head>
<body>
<canvas id="c" width="250" height="400"></canvas>
<script>
const C = document.getElementById('c');
const X = C.getContext('2d');
const G = 10; // Grid size
const S = 22; // Spacing
const OX = 26; // Offset X
const OY = 85; // Offset Y
const CARS = 180;

// Simulation Config
const MAX_SPEED = 0.8;
const ACCEL = 0.02;
const DECEL = 0.08;
const SAFE_DIST = 6;
const STOP_DIST = 10;
const LIGHT_TIME = 300; 

// Data
let nodes = [];
let roads = [];
let cars = [];

// Init Grid
for(let y=0; y<G; y++) {
    for(let x=0; x<G; x++) {
        nodes.push({
            x: OX + x*S,
            y: OY + y*S,
            gx: x, gy: y,
            state: Math.random() > 0.5 ? 0 : 1, // 0: Horiz Green, 1: Vert Green
            timer: Math.floor(Math.random() * LIGHT_TIME)
        });
    }
}

// Init Roads (Edges)
// Dir: 0=East, 1=South, 2=West, 3=North
function getRoadId(u, v) { return u.gx + "," + u.gy + "-" + v.gx + "," + v.gy; }

nodes.forEach(n => {
    let neighbors = [
        {dx:1, dy:0, dir:0}, {dx:0, dy:1, dir:1},
        {dx:-1, dy:0, dir:2}, {dx:0, dy:-1, dir:3}
    ];
    neighbors.forEach(nb => {
        let nx = n.gx + nb.dx;
        let ny = n.gy + nb.dy;
        if(nx>=0 && nx<G && ny>=0 && ny<G) {
            let target = nodes[ny*G + nx];
            roads.push({
                u: n, v: target,
                dir: nb.dir,
                cars: [],
                len: S,
                id: getRoadId(n, target)
            });
        }
    });
});

// Init Cars
for(let i=0; i<CARS; i++) {
    let r = roads[Math.floor(Math.random()*roads.length)];
    cars.push({
        road: r,
        pos: Math.random() * (r.len - 5),
        spd: 0,
        col: `hsl(${Math.random()*50 + 200}, 70%, 60%)`
    });
}
// Sort cars on roads for simple following logic
cars.forEach(c => c.road.cars.push(c));

function update() {
    // Traffic Lights
    nodes.forEach(n => {
        n.timer++;
        if(n.timer > LIGHT_TIME) {
            n.timer = 0;
            n.state = 1 - n.state; // Toggle
        }
    });

    // Clean road lists
    roads.forEach(r => r.cars.sort((a,b) => b.pos - a.pos));

    cars.forEach(c => {
        let ahead = null;
        // Find car ahead
        let idx = c.road.cars.indexOf(c);
        if(idx > 0) ahead = c.road.cars[idx-1];

        // Determine target limit (Distance to object)
        let dist = 999;
        let stopLineDist = c.road.len - c.pos;
        
        // 1. Car ahead
        if(ahead) {
            dist = (ahead.pos - c.pos) - 4; // 4 is car length
        } 
        
        // 2. Traffic Light
        // If approaching intersection, check light
        // Dir 0(E) & 2(W) check state 0 (Horiz Green). If state 1, Stop.
        // Dir 1(S) & 3(N) check state 1 (Vert Green). If state 0, Stop.
        let lightRed = false;
        let rDir = c.road.dir;
        let tlState = c.road.v.state;
        
        if ((rDir === 0 || rDir === 2) && tlState === 1) lightRed = true;
        if ((rDir === 1 || rDir === 3) && tlState === 0) lightRed = true;

        // Yellow light logic (last 15% of time)
        let isYellow = c.road.v.timer > LIGHT_TIME * 0.85;
        if(isYellow && !lightRed) {
             // If close, proceed, else stop
             if(stopLineDist > 15) lightRed = true; 
        }

        if(!ahead && lightRed) {
            dist = stopLineDist;
        }

        // Physics
        if(dist < SAFE_DIST) {
            c.spd -= DECEL * 2; // Emergency brake
        } else if (dist < STOP_DIST * 2) {
             // Approach
             let targetSpd = (dist / (STOP_DIST*2)) * MAX_SPEED;
             if(c.spd > targetSpd) c.spd -= DECEL;
             else c.spd += ACCEL;
        } else {
            if(c.spd < MAX_SPEED) c.spd += ACCEL;
        }

        if(c.spd < 0) c.spd = 0;
        
        // Jitter for natural feel
        c.spd *= (0.95 + Math.random()*0.1); 

        c.pos += c.spd;

        // Move to next road
        if(c.pos >= c.road.len) {
            // Pick random valid next road from target node (u=current.v)
            let currNode = c.road.v;
            // Filter roads starting at currNode, excluding U-turn
            let oppDir = (c.road.dir + 2) % 4;
            let possible = roads.filter(r => r.u === currNode && r.dir !== oppDir);
            
            if(possible.length > 0) {
                // Remove from old road
                c.road.cars.splice(c.road.cars.indexOf(c), 1);
                // Assign new
                c.road = possible[Math.floor(Math.random() * possible.length)];
                c.pos = 0;
                c.road.cars.push(c);
            } else {
                c.pos = c.road.len; c.spd = 0; // Dead end fallback
            }
        }
    });
}

function draw() {
    X.fillStyle = '#111';
    X.fillRect(0,0,250,400);

    // Draw Roads
    X.strokeStyle = '#333';
    X.lineWidth = 4;
    X.beginPath();
    roads.forEach(r => {
        X.moveTo(r.u.x, r.u.y);
        X.lineTo(r.v.x, r.v.y);
    });
    X.stroke();

    // Draw Lights
    nodes.forEach(n => {
        // Draw lights based on state
        // if state 0 (Horiz Green), Vert is Red
        X.fillStyle = n.state === 0 ? '#0f0' : '#f00'; // Horiz Light
        X.fillRect(n.x - 4, n.y - 1, 3, 2);
        X.fillRect(n.x + 1, n.y - 1, 3, 2);
        
        X.fillStyle = n.state === 1 ? '#0f0' : '#f00'; // Vert Light
        X.fillRect(n.x - 1, n.y - 4, 2, 3);
        X.fillRect(n.x - 1, n.y + 1, 2, 3);
    });

    // Draw Cars
    cars.forEach(c => {
        let u = c.road.u;
        let v = c.road.v;
        // Interpolate position
        let t = c.pos / c.road.len;
        let px = u.x + (v.x - u.x) * t;
        let py = u.y + (v.y - u.y) * t;
        
        // Offset for lane (Right hand drive logic)
        // Vector U->V
        let dx = v.x - u.x;
        let dy = v.y - u.y;
        let len = Math.sqrt(dx*dx + dy*dy);
        dx/=len; dy/=len;
        // Normal vector (-dy, dx)
        let off = 2.5;
        px += -dy * off;
        py += dx * off;

        X.fillStyle = c.col;
        X.save();
        X.translate(px, py);
        X.rotate(Math.atan2(dy, dx));
        X.fillRect(-2, -1.5, 4, 3); // Car body
        
        // Brake lights
        if(c.spd < 0.1) {
            X.fillStyle = '#f55';
            X.fillRect(-2, -1.5, 1, 3);
        }
        X.restore();
    });

    requestAnimationFrame(loop);
}

function loop() {
    update();
    draw();
}

loop();
</script>
</body>
</html>