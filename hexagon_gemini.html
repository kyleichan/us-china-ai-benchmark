<!DOCTYPE html>
<html>
<head>
<style>
    body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: #222;
        overflow: hidden;
    }
    canvas {
        background-color: #111;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
</style>
</head>
<body>

<canvas id="simCanvas" width="250" height="400"></canvas>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const cx = canvas.width / 2;
const cy = canvas.height / 2;

// Physics constants
const GRAVITY = 0.15;
const FRICTION = 0.99; // Air resistance
const WALL_BOUNCE = 0.7; // Energy kept after hitting wall
const BALL_RADIUS = 4;
const HEX_COUNT = 3;

let balls = [];
let frame = 0;

// Hexagon Configuration
const hexagons = [
    { r: 40,  speed: 0.02,  angle: 0, gapIndex: 0, color: '#FF4136' },
    { r: 80,  speed: -0.015, angle: 1, gapIndex: 2, color: '#2ECC40' },
    { r: 120, speed: 0.01,  angle: 2, gapIndex: 4, color: '#0074D9' }
];

class Ball {
    constructor() {
        this.x = cx;
        this.y = cy;
        // Random slight velocity to start so they don't stack perfectly
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.hue = Math.random() * 360;
        this.markedForDeletion = false;
    }

    update() {
        this.vy += GRAVITY;
        this.vx *= FRICTION;
        this.vy *= FRICTION;

        this.x += this.vx;
        this.y += this.vy;

        // Remove if off screen
        if (this.y > canvas.height + 50) {
            this.markedForDeletion = true;
        }
    }

    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, BALL_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = `hsl(${this.hue}, 70%, 60%)`;
        ctx.fill();
        ctx.closePath();
    }
}

function getHexVertices(hex) {
    let vertices = [];
    for (let i = 0; i < 6; i++) {
        let theta = hex.angle + (i * Math.PI * 2) / 6;
        let x = cx + hex.r * Math.cos(theta);
        let y = cy + hex.r * Math.sin(theta);
        vertices.push({x, y});
    }
    return vertices;
}

// Distance from point p to line segment ab
function distToSegmentSquared(p, a, b) {
    let l2 = (a.x - b.x)**2 + (a.y - b.y)**2;
    if (l2 == 0) return (p.x - a.x)**2 + (p.y - a.y)**2;
    let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    return {
        distSq: (p.x - (a.x + t * (b.x - a.x)))**2 + (p.y - (a.y + t * (b.y - a.y)))**2,
        closestX: a.x + t * (b.x - a.x),
        closestY: a.y + t * (b.y - a.y)
    };
}

function checkCollisions(ball) {
    hexagons.forEach(hex => {
        let verts = getHexVertices(hex);
        
        for (let i = 0; i < 6; i++) {
            // Skip the gap side
            if (i === hex.gapIndex) continue;

            let p1 = verts[i];
            let p2 = verts[(i + 1) % 6];

            let res = distToSegmentSquared(ball, p1, p2);
            let dist = Math.sqrt(res.distSq);

            if (dist < BALL_RADIUS) {
                // Collision detected
                
                // 1. Calculate Normal
                let dx = ball.x - res.closestX;
                let dy = ball.y - res.closestY;
                let len = Math.sqrt(dx*dx + dy*dy);
                
                // Normal vector
                let nx = dx / len;
                let ny = dy / len;
                
                // 2. Push ball out of wall (overlap correction)
                let overlap = BALL_RADIUS - dist;
                ball.x += nx * overlap;
                ball.y += ny * overlap;

                // 3. Reflect Velocity
                // v' = v - 2 * (v . n) * n
                let dot = ball.vx * nx + ball.vy * ny;
                
                ball.vx = (ball.vx - 2 * dot * nx) * WALL_BOUNCE;
                ball.vy = (ball.vy - 2 * dot * ny) * WALL_BOUNCE;
                
                // Add spin energy to ball tangent
                // Cross product scalar simplified for 2D to add rotational friction
                let tangentX = -ny;
                let tangentY = nx;
                let spinForce = hex.speed * 10; // Simple transfer of rotational momentum
                ball.vx += tangentX * spinForce;
                ball.vy += tangentY * spinForce;
            }
        }
    });
}

function drawHexagon(hex) {
    let verts = getHexVertices(hex);
    ctx.beginPath();
    ctx.lineWidth = 4;
    ctx.lineCap = "round";
    ctx.strokeStyle = hex.color;

    for (let i = 0; i < 6; i++) {
        if (i === hex.gapIndex) continue;
        let p1 = verts[i];
        let p2 = verts[(i + 1) % 6];
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
    }
    ctx.stroke();
}

function animate() {
    ctx.fillStyle = 'rgba(17, 17, 17, 0.4)'; // Trails
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Update Hexagons
    hexagons.forEach(h => {
        h.angle += h.speed;
        drawHexagon(h);
    });

    // Spawn Ball (every 10 frames)
    if (frame % 10 === 0) {
        balls.push(new Ball());
    }

    // Update Balls
    for (let i = balls.length - 1; i >= 0; i--) {
        let b = balls[i];
        b.update();
        checkCollisions(b);
        b.draw();
        if (b.markedForDeletion) {
            balls.splice(i, 1);
        }
    }

    // Limit max balls to prevent lag
    if (balls.length > 250) {
        balls.splice(0, 1);
    }

    frame++;
    requestAnimationFrame(animate);
}

animate();

</script>
</body>
</html>