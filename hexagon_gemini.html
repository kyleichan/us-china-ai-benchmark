<!DOCTYPE html>
<html>
<head>
<style>
html,body{margin:0;padding:0;width:100%;height:100%;display:flex;justify-content:center;align-items:center;background:#000}
canvas { background-color: #111; box-shadow: 0 0 20px rgba(0,0,0,0.8); }
</style>
</head>
<body>
<canvas id="c" width="500" height="670"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = 500;
const H = 670;
const CX = W / 2;
const CY = H / 2;

// Physics Constants
const GRAVITY = 0.25;
const FRICTION = 0.99; // Air resistance
const WALL_BOUNCE = 0.6; // Bounciness against walls
const WALL_FRICTION = 0.1; // Tangential force from spinning walls

// State
let startTime = Date.now();
let balls = [];
let hexagons = [];

class Hexagon {
    constructor(radius, speed, gapIndex) {
        this.radius = radius;
        this.angle = 0;
        this.speed = speed;
        this.gapIndex = gapIndex; // Which side is missing (0-5)
    }

    update() {
        this.angle += this.speed;
    }

    // Get line segments [x1, y1, x2, y2]
    getSegments() {
        let segments = [];
        for (let i = 0; i < 6; i++) {
            if (i === this.gapIndex) continue;
            
            const theta1 = this.angle + i * (Math.PI / 3);
            const theta2 = this.angle + (i + 1) * (Math.PI / 3);
            
            segments.push({
                x1: CX + this.radius * Math.cos(theta1),
                y1: CY + this.radius * Math.sin(theta1),
                x2: CX + this.radius * Math.cos(theta2),
                y2: CY + this.radius * Math.sin(theta2),
                nx: Math.cos(theta1 + Math.PI/3 + Math.PI/2), // Normal vector roughly
                ny: Math.sin(theta1 + Math.PI/3 + Math.PI/2)
            });
        }
        return segments;
    }

    draw() {
        ctx.beginPath();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        
        const segments = this.getSegments();
        segments.forEach(seg => {
            ctx.moveTo(seg.x1, seg.y1);
            ctx.lineTo(seg.x2, seg.y2);
        });
        ctx.stroke();
    }
}

class Ball {
    constructor() {
        this.r = 4 + Math.random() * 2;
        this.x = CX + (Math.random() - 0.5) * 20;
        this.y = CY + (Math.random() - 0.5) * 20;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8;
        this.color = `hsl(${Math.random() * 60 + 160}, 100%, 60%)`; // Cyans/Blues
    }

    update() {
        this.vy += GRAVITY;
        this.vx *= FRICTION;
        this.vy *= FRICTION;
        this.x += this.vx;
        this.y += this.vy;

        // Floor kill zone (reset if way off screen just in case, though usually reset handles this)
        if (this.y > H + 100) {
            // Ball is gone
        }
    }

    draw() {
        ctx.beginPath();
        ctx.fillStyle = this.color;
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
    }
}

function distToSegmentSquared(px, py, x1, y1, x2, y2) {
    const l2 = (x1 - x2) ** 2 + (y1 - y2) ** 2;
    if (l2 === 0) return (px - x1) ** 2 + (py - y1) ** 2;
    let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
    t = Math.max(0, Math.min(1, t));
    return {
        distSq: (px - (x1 + t * (x2 - x1))) ** 2 + (py - (y1 + t * (y2 - y1))) ** 2,
        closestX: x1 + t * (x2 - x1),
        closestY: y1 + t * (y2 - y1)
    };
}

function resolveCollisions() {
    // Check every ball against every wall of every hexagon
    for (let b of balls) {
        for (let h of hexagons) {
            const segments = h.getSegments();
            for (let seg of segments) {
                const res = distToSegmentSquared(b.x, b.y, seg.x1, seg.y1, seg.x2, seg.y2);
                
                // Collision check
                if (res.distSq < (b.r + 2.5) ** 2) { // 2.5 is half wall thickness
                    const dist = Math.sqrt(res.distSq);
                    const overlap = (b.r + 2.5) - dist;
                    
                    // Normal vector of collision
                    let nx = b.x - res.closestX;
                    let ny = b.y - res.closestY;
                    
                    // Normalize
                    if (dist === 0) { nx = 0; ny = -1; } 
                    else { nx /= dist; ny /= dist; }

                    // Push ball out of wall to prevent sticking
                    b.x += nx * overlap;
                    b.y += ny * overlap;

                    // Reflect velocity vector
                    const dot = b.vx * nx + b.vy * ny;
                    
                    b.vx = b.vx - 2 * dot * nx;
                    b.vy = b.vy - 2 * dot * ny;

                    // Apply energy loss
                    b.vx *= WALL_BOUNCE;
                    b.vy *= WALL_BOUNCE;

                    // Apply rotational friction from the wall
                    // Determine tangent vector
                    const tx = -ny;
                    const ty = nx;
                    
                    // Add velocity based on wall rotation direction
                    // Simple approximation: add tangential velocity based on wall speed
                    const wallForce = h.speed * h.radius * 0.1;
                    b.vx += tx * wallForce;
                    b.vy += ty * wallForce;
                }
            }
        }
    }
}

function init() {
    balls = [];
    hexagons = [];
    
    // Create nested hexagons
    // Radius, Rotation Speed, Missing Side Index
    hexagons.push(new Hexagon(70, 0.02, 0));
    hexagons.push(new Hexagon(140, -0.015, 2));
    hexagons.push(new Hexagon(210, 0.01, 4));

    // Create balls
    for (let i = 0; i < 60; i++) {
        balls.push(new Ball());
    }
    
    startTime = Date.now();
}

function loop() {
    // Check restart timer
    if (Date.now() - startTime > 10000) {
        init();
    }

    // Update
    hexagons.forEach(h => h.update());
    balls.forEach(b => b.update());
    resolveCollisions();

    // Draw
    ctx.clearRect(0, 0, W, H);
    
    // Slight trail effect for motion blur feel (optional, but sticking to clean clear here for crisp lines)
    // Actually, pure black clear looks best for physics crispness
    
    hexagons.forEach(h => h.draw());
    balls.forEach(b => b.draw());

    requestAnimationFrame(loop);
}

// Start
init();
loop();

</script>
</body>
</html>