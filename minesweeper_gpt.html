<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Minesweeper (HTML-only)</title>
  <style>
    :root{
      --w:400px;
      --h:670px;
      --bg:#c0c0c0;
      --panel:#bdbdbd;
      --shadowDark:#7b7b7b;
      --shadowLight:#ffffff;
      --text:#111;
      --red:#c80000;
      --digitBg:#1a1a1a;
      --gridBg:#bfbfbf;
      --cell:#c0c0c0;
      --cellHidden:#c0c0c0;
      --cellRevealed:#bdbdbd;
      --cellBorder:#808080;
      --cellHi:#ffffff;
      --cellLo:#7b7b7b;
      --blue:#0000ff;
      --green:#007b00;
      --red2:#ff0000;
      --navy:#00007b;
      --maroon:#7b0000;
      --teal:#007b7b;
      --black:#000000;
      --gray:#7b7b7b;
      --font: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: #2a2a2a;
      display: grid;
      place-items: center;
      font-family: var(--font);
      user-select: none;
      -webkit-user-select: none;
    }

    /* Container is fixed size: exactly 400x670 */
    #frame{
      width: var(--w);
      height: var(--h);
      background: var(--bg);
      box-sizing: border-box;
      padding: 10px;
      border: 4px solid #dcdcdc;
      border-right-color: #6f6f6f;
      border-bottom-color: #6f6f6f;
      position: relative;
      overflow: hidden;
    }

    .bevel{
      border: 3px solid var(--shadowLight);
      border-right-color: var(--shadowDark);
      border-bottom-color: var(--shadowDark);
      background: var(--panel);
      box-sizing: border-box;
    }

    #topbar{
      height: 92px;
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 10px;
    }

    .digits{
      width: 98px;
      height: 54px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2px;
      padding: 4px;
      background: #a9a9a9;
      box-sizing: border-box;
    }

    .digit{
      background: var(--digitBg);
      color: var(--red);
      font-family: var(--mono);
      font-weight: 800;
      font-size: 38px;
      line-height: 46px;
      text-align: center;
      border: 2px inset #000;
      box-sizing: border-box;
      height: 46px;
    }

    #face{
      width: 64px;
      height: 64px;
      display: grid;
      place-items: center;
      font-size: 34px;
      background: #cfcfcf;
      cursor: pointer;
    }
    #face:active{
      border: 3px solid var(--shadowDark);
      border-right-color: var(--shadowLight);
      border-bottom-color: var(--shadowLight);
    }

    #info{
      margin-top: 6px;
      font-size: 12px;
      color: #222;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    kbd{
      font-family: var(--mono);
      font-size: 11px;
      border: 1px solid #666;
      padding: 1px 5px;
      background: #eee;
    }

    #boardWrap{
      margin-top: 10px;
      padding: 8px;
      height: calc(var(--h) - 10px - 92px - 10px - 10px - 8px); /* frame padding - topbar - gap - bottom padding */
      box-sizing: border-box;
      display: grid;
      place-items: center;
      background: var(--panel);
    }

    canvas{
      background: var(--gridBg);
      image-rendering: pixelated;
      outline: none;
    }

    #footer{
      position: absolute;
      left: 10px;
      right: 10px;
      bottom: 8px;
      text-align: center;
      font-size: 11px;
      color: #222;
      opacity: .9;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="frame" class="bevel" aria-label="Minesweeper frame">
    <div id="topbar" class="bevel">
      <div class="digits bevel" title="Mines left">
        <div id="minesD" class="digit">010</div>
      </div>

      <div id="face" class="bevel" role="button" tabindex="0" aria-label="New game">ðŸ™‚</div>

      <div class="digits bevel" title="Time">
        <div id="timeD" class="digit">000</div>
      </div>

      <div id="info">
        <span>Left click: reveal</span>
        <span>Right click: flag</span>
        <span><kbd>Space</kbd>: chord</span>
        <span><kbd>R</kbd>: restart</span>
      </div>
    </div>

    <div id="boardWrap" class="bevel">
      <!-- Must be exactly 400x670 for the *canvas* per request -->
      <canvas id="game" width="400" height="670" aria-label="Minesweeper board" tabindex="0"></canvas>
    </div>

    <div id="footer">Classic Minesweeper rules: reveal all non-mine tiles. Flags are optional.</div>
  </div>

<script>
(() => {
  // Canvas must be exactly 400x670 per request.
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const minesEl = document.getElementById('minesD');
  const timeEl  = document.getElementById('timeD');
  const faceEl  = document.getElementById('face');

  // ---- Board configuration (scaled for 400x670) ----
  // Choose cell size so grid fits canvas nicely with a top margin and centered.
  const CELL = 25;            // 25px cells
  const COLS = 16;            // 16 * 25 = 400 exactly
  const ROWS = 24;            // 24 * 25 = 600
  const GRID_W = COLS * CELL; // 400
  const GRID_H = ROWS * CELL; // 600
  const GRID_X = 0;           // flush, since exactly width
  const GRID_Y = Math.floor((canvas.height - GRID_H) / 2); // center vertically in 670 => 35px margin top/bot

  // Mines density: classic-ish
  const MINES = 99; // for 16x24, similar challenge to expert but slightly taller

  // Colors for numbers (classic palette)
  const numColor = {
    1:"#0000ff", 2:"#007b00", 3:"#ff0000", 4:"#00007b",
    5:"#7b0000", 6:"#007b7b", 7:"#000000", 8:"#7b7b7b"
  };

  // Cell states
  const HIDDEN = 0, REVEALED = 1, FLAGGED = 2;

  let grid, started, over, won, flags, revealedCount, startTime, timerId, mouseDownCell, chordHeld;

  function pad3(n){
    n = Math.max(0, Math.min(999, n|0));
    return String(n).padStart(3,'0');
  }

  function setFace(){
    if (over && !won) faceEl.textContent = "ðŸ˜µ";
    else if (won) faceEl.textContent = "ðŸ˜Ž";
    else if (chordHeld) faceEl.textContent = "ðŸ˜®";
    else faceEl.textContent = "ðŸ™‚";
  }

  function reset(){
    grid = Array.from({length: ROWS}, () => Array.from({length: COLS}, () => ({
      mine:false,
      adj:0,
      state:HIDDEN
    })));
    started = false;
    over = false;
    won = false;
    flags = 0;
    revealedCount = 0;
    startTime = 0;
    mouseDownCell = null;
    chordHeld = false;
    clearInterval(timerId);
    timerId = null;
    timeEl.textContent = "000";
    minesEl.textContent = pad3(MINES);
    setFace();
    draw();
  }

  function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }

  function neighbors(r,c){
    const out = [];
    for (let dr=-1; dr<=1; dr++){
      for (let dc=-1; dc<=1; dc++){
        if (dr===0 && dc===0) continue;
        const rr=r+dr, cc=c+dc;
        if (inBounds(rr,cc)) out.push([rr,cc]);
      }
    }
    return out;
  }

  function placeMines(safeR, safeC){
    // Ensure first click is safe and has a safe neighborhood (no mines in 3x3 around first click)
    const forbidden = new Set();
    for (let dr=-1; dr<=1; dr++){
      for (let dc=-1; dc<=1; dc++){
        const rr = safeR+dr, cc=safeC+dc;
        if (inBounds(rr,cc)) forbidden.add(rr+","+cc);
      }
    }

    let placed = 0;
    while (placed < MINES){
      const r = (Math.random()*ROWS)|0;
      const c = (Math.random()*COLS)|0;
      const key = r+","+c;
      if (forbidden.has(key)) continue;
      if (grid[r][c].mine) continue;
      grid[r][c].mine = true;
      placed++;
    }

    // Compute adjacency
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        if (grid[r][c].mine) { grid[r][c].adj = 0; continue; }
        let count = 0;
        for (const [rr,cc] of neighbors(r,c)) if (grid[rr][cc].mine) count++;
        grid[r][c].adj = count;
      }
    }
  }

  function startTimer(){
    startTime = performance.now();
    timerId = setInterval(() => {
      if (!started || over || won) return;
      const t = ((performance.now()-startTime)/1000)|0;
      timeEl.textContent = pad3(t);
    }, 200);
  }

  function cellFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top)  * (canvas.height / rect.height);
    const gx = x - GRID_X, gy = y - GRID_Y;
    if (gx < 0 || gy < 0 || gx >= GRID_W || gy >= GRID_H) return null;
    const c = (gx / CELL) | 0;
    const r = (gy / CELL) | 0;
    return {r,c};
  }

  function reveal(r,c){
    if (over || won) return;
    const cell = grid[r][c];
    if (cell.state === REVEALED || cell.state === FLAGGED) return;

    if (!started){
      placeMines(r,c);
      started = true;
      startTimer();
    }

    cell.state = REVEALED;
    revealedCount++;

    if (cell.mine){
      over = true;
      clearInterval(timerId);
      timerId = null;
      // Reveal all mines
      for (let rr=0; rr<ROWS; rr++){
        for (let cc=0; cc<COLS; cc++){
          if (grid[rr][cc].mine) grid[rr][cc].state = REVEALED;
        }
      }
      setFace();
      draw();
      return;
    }

    if (cell.adj === 0){
      // flood fill
      const q = [[r,c]];
      const seen = new Set([r+","+c]);
      while (q.length){
        const [cr,cc] = q.shift();
        for (const [nr,nc] of neighbors(cr,cc)){
          const ncell = grid[nr][nc];
          if (ncell.state === REVEALED || ncell.state === FLAGGED) continue;
          if (ncell.mine) continue;
          const key = nr+","+nc;
          if (!seen.has(key)){
            ncell.state = REVEALED;
            revealedCount++;
            seen.add(key);
            if (ncell.adj === 0) q.push([nr,nc]);
          }
        }
      }
    }

    checkWin();
    draw();
  }

  function toggleFlag(r,c){
    if (over || won) return;
    const cell = grid[r][c];
    if (cell.state === REVEALED) return;

    if (cell.state === HIDDEN){
      cell.state = FLAGGED;
      flags++;
    } else if (cell.state === FLAGGED){
      cell.state = HIDDEN;
      flags--;
    }
    minesEl.textContent = pad3(MINES - flags);
    draw();
  }

  function chord(r,c){
    // If a revealed number has exactly that many flags around it, reveal the rest.
    if (over || won) return;
    const cell = grid[r][c];
    if (cell.state !== REVEALED) return;
    if (cell.adj <= 0) return;

    let f = 0;
    const neigh = neighbors(r,c);
    for (const [rr,cc] of neigh) if (grid[rr][cc].state === FLAGGED) f++;
    if (f !== cell.adj) return;

    for (const [rr,cc] of neigh){
      if (grid[rr][cc].state === HIDDEN) reveal(rr,cc);
    }
    draw();
  }

  function checkWin(){
    const totalSafe = ROWS*COLS - MINES;
    if (revealedCount >= totalSafe && !over){
      won = true;
      clearInterval(timerId);
      timerId = null;
      // Auto-flag remaining mines (optional)
      for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLS;c++){
          const cell = grid[r][c];
          if (cell.mine && cell.state !== FLAGGED){
            cell.state = FLAGGED;
          }
        }
      }
      flags = MINES;
      minesEl.textContent = pad3(0);
      setFace();
    }
  }

  // ---- Drawing ----
  function bevelRect(x,y,w,h,raised=true){
    // classic 3D bevel
    const hi = "#ffffff";
    const lo = "#7b7b7b";
    ctx.fillStyle = raised ? "#c0c0c0" : "#bdbdbd";
    ctx.fillRect(x,y,w,h);

    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.strokeStyle = raised ? hi : lo; // top/left
    ctx.moveTo(x+1,y+h-1);
    ctx.lineTo(x+1,y+1);
    ctx.lineTo(x+w-1,y+1);
    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = raised ? lo : hi; // bottom/right
    ctx.moveTo(x+1,y+h-1);
    ctx.lineTo(x+w-1,y+h-1);
    ctx.lineTo(x+w-1,y+1);
    ctx.stroke();
  }

  function drawCell(r,c){
    const x = GRID_X + c*CELL;
    const y = GRID_Y + r*CELL;
    const cell = grid[r][c];

    if (cell.state === HIDDEN){
      bevelRect(x,y,CELL,CELL,true);
      return;
    }

    if (cell.state === FLAGGED){
      bevelRect(x,y,CELL,CELL,true);
      // flag pole
      ctx.strokeStyle = "#111";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + CELL*0.52, y + CELL*0.20);
      ctx.lineTo(x + CELL*0.52, y + CELL*0.80);
      ctx.stroke();
      // flag triangle
      ctx.fillStyle = "#c80000";
      ctx.beginPath();
      ctx.moveTo(x + CELL*0.52, y + CELL*0.22);
      ctx.lineTo(x + CELL*0.22, y + CELL*0.36);
      ctx.lineTo(x + CELL*0.52, y + CELL*0.50);
      ctx.closePath();
      ctx.fill();
      // base
      ctx.fillStyle = "#111";
      ctx.fillRect(x + CELL*0.30, y + CELL*0.78, CELL*0.45, 2);
      return;
    }

    // REVEALED
    ctx.fillStyle = "#bdbdbd";
    ctx.fillRect(x,y,CELL,CELL);
    // inset border
    ctx.strokeStyle = "#9a9a9a";
    ctx.lineWidth = 1;
    ctx.strokeRect(x+0.5,y+0.5,CELL-1,CELL-1);

    if (cell.mine){
      // mine
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(x+CELL/2, y+CELL/2, CELL*0.22, 0, Math.PI*2);
      ctx.fill();
      // spikes
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      for (let i=0;i<8;i++){
        const a = i*Math.PI/4;
        const r1 = CELL*0.12, r2 = CELL*0.34;
        ctx.beginPath();
        ctx.moveTo(x+CELL/2 + Math.cos(a)*r1, y+CELL/2 + Math.sin(a)*r1);
        ctx.lineTo(x+CELL/2 + Math.cos(a)*r2, y+CELL/2 + Math.sin(a)*r2);
        ctx.stroke();
      }
      // highlight
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(x+CELL*0.43, y+CELL*0.43, CELL*0.05, 0, Math.PI*2);
      ctx.fill();
      // red background if exploded (the one clicked)
      return;
    }

    if (cell.adj > 0){
      ctx.fillStyle = numColor[cell.adj] || "#000";
      ctx.font = `bold ${Math.floor(CELL*0.65)}px ${getComputedStyle(document.documentElement).getPropertyValue('--font')}`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(cell.adj), x + CELL/2, y + CELL/2 + 1);
    }
  }

  function drawGridLines(){
    ctx.strokeStyle = "#a0a0a0";
    ctx.lineWidth = 1;
    // subtle grid lines
    for (let c=0; c<=COLS; c++){
      const x = GRID_X + c*CELL + 0.5;
      ctx.beginPath();
      ctx.moveTo(x, GRID_Y + 0.5);
      ctx.lineTo(x, GRID_Y + GRID_H + 0.5);
      ctx.stroke();
    }
    for (let r=0; r<=ROWS; r++){
      const y = GRID_Y + r*CELL + 0.5;
      ctx.beginPath();
      ctx.moveTo(GRID_X + 0.5, y);
      ctx.lineTo(GRID_X + GRID_W + 0.5, y);
      ctx.stroke();
    }
  }

  function draw(){
    // clear whole canvas (including margins)
    ctx.fillStyle = "#bfbfbf";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // outer board bevel around the grid region
    const pad = 6;
    const bx = GRID_X - pad, by = GRID_Y - pad, bw = GRID_W + pad*2, bh = GRID_H + pad*2;

    // Clamp in case padding goes negative (it won't here, but keep safe)
    const cbx = Math.max(0, bx), cby = Math.max(0, by);
    const cbw = Math.min(canvas.width - cbx, bw - (cbx - bx));
    const cbh = Math.min(canvas.height - cby, bh - (cby - by));

    // beveled frame
    ctx.fillStyle = "#a9a9a9";
    ctx.fillRect(cbx,cby,cbw,cbh);
    // bevel lines
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#ffffff";
    ctx.beginPath();
    ctx.moveTo(cbx+1, cby+cbh-1);
    ctx.lineTo(cbx+1, cby+1);
    ctx.lineTo(cbx+cbw-1, cby+1);
    ctx.stroke();
    ctx.strokeStyle = "#7b7b7b";
    ctx.beginPath();
    ctx.moveTo(cbx+1, cby+cbh-1);
    ctx.lineTo(cbx+cbw-1, cby+cbh-1);
    ctx.lineTo(cbx+cbw-1, cby+1);
    ctx.stroke();

    // draw cells
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        drawCell(r,c);
      }
    }

    drawGridLines();

    // If game over, mark incorrect flags / show explosion cell? Keep simple:
    if (over){
      // highlight wrong flags
      for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLS;c++){
          const cell = grid[r][c];
          const x = GRID_X + c*CELL;
          const y = GRID_Y + r*CELL;
          if (cell.state === FLAGGED && !cell.mine){
            // X
            ctx.strokeStyle = "#c80000";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x+5,y+5); ctx.lineTo(x+CELL-5,y+CELL-5);
            ctx.moveTo(x+CELL-5,y+5); ctx.lineTo(x+5,y+CELL-5);
            ctx.stroke();
          }
        }
      }
    }

    setFace();
  }

  // ---- Input ----
  canvas.addEventListener('contextmenu', e => e.preventDefault());

  canvas.addEventListener('mousedown', (e) => {
    const cell = cellFromEvent(e);
    if (!cell) return;

    canvas.focus();

    if (e.button === 0){ // left
      mouseDownCell = cell;
      chordHeld = true;
      setFace();
      draw();
    } else if (e.button === 2){ // right
      toggleFlag(cell.r, cell.c);
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    const cell = cellFromEvent(e);
    chordHeld = false;

    if (e.button === 0 && mouseDownCell){
      // If mouse up on same cell, reveal; if on revealed cell with Space chord, handle separately
      if (cell && cell.r === mouseDownCell.r && cell.c === mouseDownCell.c){
        const target = grid[cell.r][cell.c];
        if (target.state === REVEALED){
          // do nothing; chord via Space (or double click below)
        } else {
          reveal(cell.r, cell.c);
        }
      }
      mouseDownCell = null;
    }
    setFace();
    draw();
  });

  canvas.addEventListener('dblclick', (e) => {
    const cell = cellFromEvent(e);
    if (!cell) return;
    chord(cell.r, cell.c);
  });

  // Keyboard: R to restart, Space to chord the hovered/last cell via mouse position (uses center under cursor)
  canvas.addEventListener('keydown', (e) => {
    if (e.key === 'r' || e.key === 'R'){
      reset();
      return;
    }
    if (e.code === 'Space'){
      e.preventDefault();
      // chord under last known mouse position: use stored mouseDownCell if any, else use center of canvas (best effort)
      // We'll chord the cell under current mouse if possible via lastMouse.
      if (lastMouseCell) chord(lastMouseCell.r, lastMouseCell.c);
    }
  });

  let lastMouseCell = null;
  canvas.addEventListener('mousemove', (e) => {
    lastMouseCell = cellFromEvent(e);
  });

  faceEl.addEventListener('click', reset);
  faceEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') reset();
  });

  // Initial
  reset();
})();
</script>
</body>
</html>