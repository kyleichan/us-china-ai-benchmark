<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Double Pendulum Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a; /* Slate 900 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            border-radius: 8px;
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
        }
        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .stats {
            font-variant-numeric: tabular-nums;
        }
    </style>
</head>
<body>

    <div class="overlay">
        <h1 class="text-2xl font-bold tracking-wider mb-1">CHAOS ENGINE</h1>
        <div class="text-xs text-slate-400 uppercase tracking-widest mb-4">Double Pendulum System</div>
        
        <div class="space-y-1 text-sm font-mono stats">
            <div class="flex justify-between w-48"><span>Energy:</span> <span id="energy-val" class="text-cyan-400">0.00 J</span></div>
            <div class="flex justify-between w-48"><span>Velocity:</span> <span id="vel-val" class="text-pink-400">0.00 rad/s</span></div>
            <div class="flex justify-between w-48"><span>Push Timer:</span> <span id="push-timer" class="text-yellow-400">10.0s</span></div>
        </div>
        
        <div class="mt-6 text-xs text-slate-500 max-w-[200px] leading-relaxed">
            A deterministic system exhibiting sensitive dependence on initial conditions. 
            <br><br>
            <span class="text-cyan-500">Tip:</span> Push magnitude randomized every 10s.
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container" class="relative">
        <canvas id="simCanvas"></canvas>
    </div>

    <script>
        /**
         * DOUBLE PENDULUM SIMULATION
         * Physics implementation using RK4 integration for stability.
         * Rendered on HTML5 Canvas.
         */

        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        // UI Elements
        const energyEl = document.getElementById('energy-val');
        const velEl = document.getElementById('vel-val');
        const pushTimerEl = document.getElementById('push-timer');

        // Configuration
        let width, height, originX, originY;
        const scale = 150; // Pixels per meter
        
        // Physics State
        // theta1, omega1, theta2, omega2
        let state = {
            t1: Math.PI / 1.9, // Start near top (almost vertical up)
            w1: 0,
            t2: Math.PI / 1.9,
            w2: 0
        };

        // Physical Constants
        const g = 9.81;       // Gravity (m/s^2)
        const m1 = 1.0;       // Mass 1 (kg)
        const m2 = 1.0;       // Mass 2 (kg)
        const l1 = 1.0;       // Length 1 (m)
        const l2 = 1.0;       // Length 2 (m)
        
        // Simulation Constants
        const dt = 0.016;     // Time step (approx 60fps)
        let lastPushTime = 0;
        const pushInterval = 10; // Seconds

        // Trail System
        const maxTrailLength = 400;
        const trail = []; // {x, y, v}

        // Resize Handler
        function resize() {
            // Make canvas fit nicely in window but maintain aspect or just fill available space reasonably
            // Let's make it a nice square or responsive block
            const size = Math.min(window.innerWidth - 40, window.innerHeight - 40, 800);
            canvas.width = size;
            canvas.height = size;
            width = canvas.width;
            height = canvas.height;
            originX = width / 2;
            originY = height / 4; // Anchor point near top
        }
        window.addEventListener('resize', resize);
        resize();

        // Physics Derivatives
        // Returns [dtheta1/dt, domega1/dt, dtheta2/dt, domega2/dt]
        function getDerivatives(s) {
            const { t1, w1, t2, w2 } = s;
            
            const delta = t1 - t2;
            const sinDelta = Math.sin(delta);
            const cosDelta = Math.cos(delta);
            
            const den1 = (m1 + m2) * l1 - m2 * l1 * cosDelta * cosDelta;
            const den2 = (l2 / l1) * den1;

            // Angular Acceleration 1
            const num1 = m2 * l1 * w1 * w1 * sinDelta * cosDelta +
                         m2 * g * Math.sin(t2) * cosDelta +
                         m2 * l2 * w2 * w2 * sinDelta -
                         (m1 + m2) * g * Math.sin(t1);
            
            const alpha1 = num1 / den1;

            // Angular Acceleration 2
            const num2 = -m2 * l2 * w2 * w2 * sinDelta * cosDelta +
                         (m1 + m2) * (g * Math.sin(t1) * cosDelta - l1 * w1 * w1 * sinDelta - g * Math.sin(t2));
            
            const alpha2 = num2 / den2;

            return [w1, alpha1, w2, alpha2];
        }

        // RK4 Integration Step
        function integrate() {
            const s = state;
            
            const k1 = getDerivatives(s);
            
            const s2 = {
                t1: s.t1 + k1[0] * dt * 0.5,
                w1: s.w1 + k1[1] * dt * 0.5,
                t2: s.t2 + k1[2] * dt * 0.5,
                w2: s.w2 + k1[3] * dt * 0.5
            };
            const k2 = getDerivatives(s2);
            
            const s3 = {
                t1: s.t1 + k2[0] * dt * 0.5,
                w1: s.w1 + k2[1] * dt * 0.5,
                t2: s.t2 + k2[2] * dt * 0.5,
                w2: s.w2 + k2[3] * dt * 0.5
            };
            const k3 = getDerivatives(s3);
            
            const s4 = {
                t1: s.t1 + k3[0] * dt,
                w1: s.w1 + k3[1] * dt,
                t2: s.t2 + k3[2] * dt,
                w2: s.w2 + k3[3] * dt
            };
            const k4 = getDerivatives(s4);

            // Update State
            state.t1 += (dt / 6.0) * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
            state.w1 += (dt / 6.0) * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);
            state.t2 += (dt / 6.0) * (k1[2] + 2*k2[2] + 2*k3[2] + k4[2]);
            state.w2 += (dt / 6.0) * (k1[3] + 2*k2[3] + 2*k3[3] + k4[3]);
        }

        // Calculate Cartesian Coordinates
        function getCoords() {
            const x1 = originX + l1 * scale * Math.sin(state.t1);
            const y1 = originY + l1 * scale * Math.cos(state.t1);
            const x2 = x1 + l2 * scale * Math.sin(state.t2);
            const y2 = y1 + l2 * scale * Math.cos(state.t2);
            return { x1, y1, x2, y2 };
        }

        // Calculate Total Energy (for debugging/display)
        function calculateEnergy() {
            // Potential Energy
            const h1 = -l1 * Math.cos(state.t1);
            const h2 = h1 - l2 * Math.cos(state.t2);
            const pe = m1 * g * h1 + m2 * g * h2;

            // Kinetic Energy
            // v1^2 = (l1 * w1)^2
            const v1_sq = (l1 * state.w1)**2;
            
            // v2^2 = v1^2 + (l2*w2)^2 + 2*v1*(l2*w2)*cos(delta)
            // Simplified vector addition:
            // vx1 = l1*w1*cos(t1), vy1 = -l1*w1*sin(t1)
            // vx2 = l2*w2*cos(t2), vy2 = -l2*w2*sin(t2)
            // V_total_x = vx1 + vx2, V_total_y = vy1 + vy2
            const vx1 = l1 * state.w1 * Math.cos(state.t1);
            const vy1 = -l1 * state.w1 * Math.sin(state.t1);
            const vx2_rel = l2 * state.w2 * Math.cos(state.t2);
            const vy2_rel = -l2 * state.w2 * Math.sin(state.t2);
            
            const v2_sq = (vx1 + vx2_rel)**2 + (vy1 + vy2_rel)**2;

            const ke = 0.5 * m1 * v1_sq + 0.5 * m2 * v2_sq;

            return pe + ke;
        }

        // Drawing Helpers
        function drawPendulum() {
            const { x1, y1, x2, y2 } = getCoords();

            // Draw Rod 1
            ctx.beginPath();
            ctx.moveTo(originX, originY);
            ctx.lineTo(x1, y1);
            ctx.strokeStyle = '#94a3b8'; // Slate 400
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.stroke();

            // Draw Rod 2
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 4;
            ctx.stroke();

            // Draw Mass 1
            ctx.beginPath();
            ctx.arc(x1, y1, 10, 0, Math.PI * 2);
            ctx.fillStyle = '#22d3ee'; // Cyan 400
            ctx.fill();
            ctx.shadowColor = '#22d3ee';
            ctx.shadowBlur = 15;
            ctx.stroke();
            ctx.shadowBlur = 0; // Reset

            // Draw Mass 2
            ctx.beginPath();
            ctx.arc(x2, y2, 10, 0, Math.PI * 2);
            ctx.fillStyle = '#f472b6'; // Pink 400
            ctx.fill();
            ctx.shadowColor = '#f472b6';
            ctx.shadowBlur = 15;
            ctx.stroke();
            ctx.shadowBlur = 0; // Reset

            // Draw Pivot
            ctx.beginPath();
            ctx.arc(originX, originY, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
        }

        function drawTrail() {
            if (trail.length < 2) return;

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            for (let i = 0; i < trail.length - 1; i++) {
                const p1 = trail[i];
                const p2 = trail[i+1];
                
                // Color based on velocity (speed of mass 2)
                // Normalize velocity for color mapping (0 to 10 rad/s -> Hue)
                const speed = Math.abs(p1.v);
                const hue = Math.min(280, speed * 30); // Map speed to hue (Blue to Purple to Pink)
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                
                // Fade out alpha based on age
                const alpha = i / trail.length;
                ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${alpha})`;
                ctx.lineWidth = 2 + (alpha * 2);
                ctx.stroke();
            }
        }

        // Main Loop
        let lastTime = performance.now();
        let accumulatedTime = 0;

        function loop() {
            requestAnimationFrame(loop);
            
            const now = performance.now();
            // const deltaTime = (now - lastTime) / 1000; // Real seconds elapsed
            lastTime = now;
            accumulatedTime += dt;

            // Physics Sub-stepping (optional, but RK4 is good enough usually. 
            // Let's just run 1 RK4 step per frame for 60fps visual)
            integrate();

            // Handle Automatic Push
            const timeSincePush = accumulatedTime - lastPushTime;
            const timeLeft = Math.max(0, pushInterval - timeSincePush);
            pushTimerEl.textContent = timeLeft.toFixed(1) + 's';

            if (timeSincePush >= pushInterval) {
                // PUSH!
                const pushStrength = (Math.random() * 10 + 5); // Random magnitude
                const pushDir = Math.random() > 0.5 ? 1 : -1;
                
                // Add to angular velocity of the first pendulum
                state.w1 += pushStrength * pushDir * 0.5;
                state.w2 += pushStrength * pushDir * 0.2;
                
                lastPushTime = accumulatedTime;
                
                // Visual feedback flash
                flashScreen();
            }

            // Update Trail
            const { x2, y2 } = getCoords();
            // Velocity of mass 2 (approximate for color)
            const v2 = Math.sqrt(state.w1**2 + state.w2**2); // Rough approx for color
            
            trail.push({ x: x2, y: y2, v: v2 });
            if (trail.length > maxTrailLength) {
                trail.shift();
            }

            // Clear & Draw
            ctx.clearRect(0, 0, width, height);
            
            // Draw Grid (Subtle)
            drawGrid();

            drawTrail();
            drawPendulum();

            // Update Stats
            if (Math.floor(now) % 5 === 0) { // Update text occasionally
                energyEl.textContent = calculateEnergy().toFixed(2) + ' J';
                velEl.textContent = v2.toFixed(2) + ' rad/s';
            }
        }

        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            
            ctx.beginPath();
            for(let x = 0; x < width; x += gridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
            }
            for(let y = 0; y < height; y += gridSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
            }
            ctx.stroke();
        }

        function flashScreen() {
            const flash = document.createElement('div');
            flash.className = 'absolute inset-0 bg-white opacity-20 pointer-events-none transition-opacity duration-500';
            document.body.appendChild(flash);
            setTimeout(() => {
                flash.classList.add('opacity-0');
                setTimeout(() => flash.remove(), 500);
            }, 50);
        }

        // Start
        loop();

    </script>
</body>
</html>