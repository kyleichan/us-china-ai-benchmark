<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>* { margin: 0; padding: 0; } body { background: #0a0a14; overflow: hidden; } canvas { display: block; }</style>
</head>
<body>
<canvas id="canvas" width="500" height="670"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const HEX_SIDES = 6;
const HEX_COUNT = 3;
const HEX_RADIUS_STEP = 80;
const BALL_COUNT = 12;
const RESTART_INTERVAL = 10000;

let hexagons = [];
let balls = [];
let animationId = null;
let restartTimeout = null;

class Hexagon {
    constructor(radiusOffset, rotationSpeed) {
        this.radius = 100 + radiusOffset * HEX_RADIUS_STEP;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = rotationSpeed;
        this.missingSide = Math.floor(Math.random() * HEX_SIDES);
        this.vertices = [];
        this.updateVertices();
    }

    updateVertices() {
        this.vertices = [];
        for (let i = 0; i < HEX_SIDES; i++) {
            if (i === this.missingSide) continue;
            const angle = this.rotation + (i * Math.PI * 2) / HEX_SIDES;
            this.vertices.push({
                x: canvas.width / 2 + Math.cos(angle) * this.radius,
                y: canvas.height / 2 + Math.sin(angle) * this.radius
            });
        }
    }

    update(deltaTime) {
        this.rotation += this.rotationSpeed * deltaTime;
        this.updateVertices();
    }

    draw() {
        ctx.beginPath();
        ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
        for (let i = 1; i < this.vertices.length; i++) {
            ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
        }
        ctx.closePath();
        ctx.strokeStyle = `hsl(${this.radius}, 70%, 60%)`;
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    getEdges() {
        const edges = [];
        for (let i = 0; i < this.vertices.length; i++) {
            edges.push({
                x1: this.vertices[i].x,
                y1: this.vertices[i].y,
                x2: this.vertices[(i + 1) % this.vertices.length].x,
                y2: this.vertices[(i + 1) % this.vertices.length].y
            });
        }
        return edges;
    }
}

class Ball {
    constructor() {
        this.reset();
        this.radius = 4 + Math.random() * 4;
        this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
        this.friction = 0.99;
        this.bounceFactor = 0.8;
    }

    reset() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        const speed = 0.5 + Math.random() * 2;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.active = true;
    }

    update(deltaTime) {
        if (!this.active) return;

        this.vy += 0.05 * deltaTime;
        this.x += this.vx * deltaTime;
        this.y += this.vy * deltaTime;
        this.vx *= this.friction;
        this.vy *= this.friction;

        if (this.x < this.radius || this.x > canvas.width - this.radius) {
            this.vx = -this.vx * this.bounceFactor;
            this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
        }
        if (this.y < this.radius || this.y > canvas.height - this.radius) {
            this.vy = -this.vy * this.bounceFactor;
            this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
        }

        this.checkHexagonCollisions();
        if (this.isOutsideAllHexagons()) {
            this.active = false;
        }
    }

    checkHexagonCollisions() {
        for (const hex of hexagons) {
            const edges = hex.getEdges();
            for (const edge of edges) {
                const closest = this.closestPointOnLineSegment(edge.x1, edge.y1, edge.x2, edge.y2);
                const dx = this.x - closest.x;
                const dy = this.y - closest.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < this.radius) {
                    const nx = dx / distance;
                    const ny = dy / distance;
                    const dot = this.vx * nx + this.vy * ny;
                    this.vx = (this.vx - 2 * dot * nx) * this.bounceFactor;
                    this.vy = (this.vy - 2 * dot * ny) * this.bounceFactor;
                    this.x = closest.x + nx * this.radius * 1.1;
                    this.y = closest.y + ny * this.radius * 1.1;
                }
            }
        }
    }

    closestPointOnLineSegment(x1, y1, x2, y2) {
        const A = this.x - x1;
        const B = this.y - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = lenSq !== 0 ? dot / lenSq : -1;
        param = Math.max(0, Math.min(1, param));
        return {
            x: x1 + param * C,
            y: y1 + param * D
        };
    }

    isOutsideAllHexagons() {
        for (const hex of hexagons) {
            const dx = this.x - canvas.width / 2;
            const dy = this.y - canvas.height / 2;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < hex.radius) return false;
        }
        return true;
    }

    draw() {
        if (!this.active) return;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fill();
    }
}

function init() {
    hexagons = [];
    balls = [];

    for (let i = 0; i < HEX_COUNT; i++) {
        hexagons.push(new Hexagon(i, (i % 2 ? 1 : -1) * (0.5 + Math.random() * 0.5)));
    }

    for (let i = 0; i < BALL_COUNT; i++) {
        balls.push(new Ball());
    }

    if (restartTimeout) clearTimeout(restartTimeout);
    restartTimeout = setTimeout(init, RESTART_INTERVAL);
}

function animate(timestamp) {
    if (!animationId) animationId = requestAnimationFrame(animate);
    const deltaTime = Math.min(1 / 60, (timestamp - (lastTime || timestamp)) / 1000);
    lastTime = timestamp;

    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (const hex of hexagons) {
        hex.update(deltaTime * 60);
        hex.draw();
    }

    let activeBalls = 0;
    for (const ball of balls) {
        ball.update(deltaTime * 60);
        ball.draw();
        if (ball.active) activeBalls++;
    }

    if (activeBalls === 0) {
        for (const ball of balls) ball.reset();
    }

    animationId = requestAnimationFrame(animate);
}

let lastTime = 0;
init();
animate();
</script>
</body>
</html>