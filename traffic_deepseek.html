<!DOCTYPE html>
<html>
<head>
    <title>Urban Traffic Simulation</title>
    <style>
        body { margin: 0; padding: 0; background: #111; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        canvas { display: block; border: 1px solid #333; }
    </style>
</head>
<body>
<canvas id="trafficCanvas" width="250" height="400"></canvas>
<script>
const canvas = document.getElementById('trafficCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const GRID_SIZE = 10;
const CELL_W = W / GRID_SIZE, CELL_H = H / GRID_SIZE;
const MAX_VEHICLES = 40;
const MAX_SPEED = 1.2;
const MIN_FOLLOW_DIST = 8;
const LIGHT_CYCLE = 180;

let vehicles = [];
let lights = [];
let frame = 0;

class TrafficLight {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.horizontalGreen = Math.random() > 0.5;
        this.timer = Math.floor(Math.random() * LIGHT_CYCLE);
    }
    update() {
        this.timer = (this.timer + 1) % LIGHT_CYCLE;
        if (this.timer === 0) this.horizontalGreen = !this.horizontalGreen;
    }
    draw() {
        ctx.save();
        ctx.translate(this.x * CELL_W, this.y * CELL_H);
        ctx.fillStyle = this.horizontalGreen ? '#0f0' : '#f00';
        ctx.beginPath();
        ctx.arc(CELL_W/2, CELL_H/2, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }
    isRed(dir) {
        return (dir === 'h' && !this.horizontalGreen) || (dir === 'v' && this.horizontalGreen);
    }
}

class Vehicle {
    constructor() {
        this.reset();
        this.x = this.sx * CELL_W + CELL_W/2;
        this.y = this.sy * CELL_H + CELL_H/2;
        this.vx = 0;
        this.vy = 0;
        this.speed = MAX_SPEED * (0.8 + Math.random()*0.4);
        this.size = 4;
        this.color = `hsl(${Math.random()*60 + 10}, 100%, 60%)`;
    }
    reset() {
        this.sx = Math.floor(Math.random() * GRID_SIZE);
        this.sy = Math.floor(Math.random() * GRID_SIZE);
        this.tx = Math.floor(Math.random() * GRID_SIZE);
        this.ty = Math.floor(Math.random() * GRID_SIZE);
        while (this.sx === this.tx && this.sy === this.ty) {
            this.tx = Math.floor(Math.random() * GRID_SIZE);
            this.ty = Math.floor(Math.random() * GRID_SIZE);
        }
        this.path = [];
        this.calcPath();
    }
    calcPath() {
        this.path = [];
        let cx = this.sx, cy = this.sy;
        while (cx !== this.tx || cy !== this.ty) {
            if (Math.random() < 0.5 && cx !== this.tx) {
                cx += cx < this.tx ? 1 : -1;
                this.path.push({x: cx, y: cy, dir: 'h'});
            } else if (cy !== this.ty) {
                cy += cy < this.ty ? 1 : -1;
                this.path.push({x: cx, y: cy, dir: 'v'});
            }
        }
    }
    getCurrentTarget() {
        if (this.path.length === 0) return null;
        const next = this.path[0];
        return {
            x: next.x * CELL_W + CELL_W/2,
            y: next.y * CELL_H + CELL_H/2,
            dir: next.dir,
            ix: next.x,
            iy: next.y
        };
    }
    update() {
        const target = this.getCurrentTarget();
        if (!target) {
            this.reset();
            return;
        }
        let dx = target.x - this.x;
        let dy = target.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 2) {
            this.path.shift();
            return;
        }
        dx /= dist;
        dy /= dist;
        const light = lights.find(l => l.x === target.ix && l.y === target.iy);
        const lightDist = Math.abs(target.x - this.x) + Math.abs(target.y - this.y);
        let stopForLight = light && light.isRed(target.dir) && lightDist < MIN_FOLLOW_DIST*2;
        let desiredSpeed = this.speed;
        vehicles.forEach(v => {
            if (v === this) return;
            const d = Math.hypot(v.x - this.x, v.y - this.y);
            if (d < MIN_FOLLOW_DIST) {
                const dot = (v.x - this.x)*dx + (v.y - this.y)*dy;
                if (dot > 0) desiredSpeed = Math.min(desiredSpeed, d - 2);
            }
        });
        if (stopForLight) desiredSpeed = 0;
        const acc = 0.1;
        this.vx += (dx * desiredSpeed - this.vx) * acc;
        this.vy += (dy * desiredSpeed - this.vy) * acc;
        this.x += this.vx;
        this.y += this.vy;
        if (this.x < 0) this.x = 0;
        if (this.x > W) this.x = W;
        if (this.y < 0) this.y = 0;
        if (this.y > H) this.y = H;
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(Math.atan2(this.vy, this.vx));
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.size, -this.size/2, this.size*2, this.size);
        ctx.fillStyle = '#fff';
        ctx.fillRect(this.size-2, -1, 2, 2);
        ctx.restore();
    }
}

function init() {
    vehicles = [];
    lights = [];
    for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
            if (Math.random() < 0.3) lights.push(new TrafficLight(i, j));
        }
    }
    for (let i = 0; i < MAX_VEHICLES; i++) {
        vehicles.push(new Vehicle());
    }
}

function drawGrid() {
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1;
    for (let i = 0; i <= GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_W, 0);
        ctx.lineTo(i * CELL_W, H);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * CELL_H);
        ctx.lineTo(W, i * CELL_H);
        ctx.stroke();
    }
}

function animate() {
    frame++;
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, W, H);
    drawGrid();
    lights.forEach(l => { l.update(); l.draw(); });
    vehicles.forEach(v => v.update());
    vehicles.forEach(v => v.draw());
    requestAnimationFrame(animate);
}

init();
animate();
</script>
</body>
</html>