<!DOCTYPE html>
<html>
<head>
    <title>Traffic Simulation</title>
    <style>
        body { margin:0; padding:0; background:#111; }
        canvas { display:block; }
    </style>
</head>
<body>
<canvas id="trafficCanvas"></canvas>
<script>
const canvas = document.getElementById('trafficCanvas');
const ctx = canvas.getContext('2d');
canvas.width = 250;
canvas.height = 400;

const GRID_SIZE = 10;
const CELL_SIZE = Math.min(canvas.width, canvas.height) / (GRID_SIZE + 2);
const ROAD_WIDTH = CELL_SIZE * 0.7;
const LANE_OFFSET = ROAD_WIDTH / 4;

const INTERSECTION_SIZE = CELL_SIZE;
const VEHICLE_SIZE = CELL_SIZE * 0.3;
const MAX_VEHICLES = 40;
const SPAWN_RATE = 0.02;
const MAX_SPEED = 1.5;
const FOLLOW_DISTANCE = VEHICLE_SIZE * 1.5;
const BRAKE_FACTOR = 0.9;
const ACCELERATION = 0.05;

class TrafficLight {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.state = Math.random() > 0.5 ? 'green' : 'red';
        this.timer = 0;
        this.cycleTime = 120 + Math.random() * 180;
    }
    update() {
        this.timer++;
        if (this.timer > this.cycleTime) {
            this.state = this.state === 'green' ? 'red' : 'green';
            this.timer = 0;
        }
    }
    draw() {
        ctx.save();
        ctx.translate(this.x * CELL_SIZE + CELL_SIZE/2, this.y * CELL_SIZE + CELL_SIZE/2);
        ctx.fillStyle = this.state === 'green' ? '#0f0' : '#f00';
        ctx.beginPath();
        ctx.arc(0, 0, CELL_SIZE/8, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class Vehicle {
    constructor() {
        this.reset();
        this.color = `hsl(${Math.random()*60 + 200}, 80%, 60%)`;
    }
    reset() {
        const edge = Math.floor(Math.random() * 4);
        let startX, startY, destX, destY;
        
        switch(edge) {
            case 0: 
                startX = Math.floor(Math.random() * GRID_SIZE);
                startY = 0;
                destX = Math.floor(Math.random() * GRID_SIZE);
                destY = GRID_SIZE - 1;
                break;
            case 1:
                startX = GRID_SIZE - 1;
                startY = Math.floor(Math.random() * GRID_SIZE);
                destX = 0;
                destY = Math.floor(Math.random() * GRID_SIZE);
                break;
            case 2:
                startX = Math.floor(Math.random() * GRID_SIZE);
                startY = GRID_SIZE - 1;
                destX = Math.floor(Math.random() * GRID_SIZE);
                destY = 0;
                break;
            case 3:
                startX = 0;
                startY = Math.floor(Math.random() * GRID_SIZE);
                destX = GRID_SIZE - 1;
                destY = Math.floor(Math.random() * GRID_SIZE);
                break;
        }
        
        this.x = startX * CELL_SIZE + CELL_SIZE/2;
        this.y = startY * CELL_SIZE + CELL_SIZE/2;
        this.destX = destX * CELL_SIZE + CELL_SIZE/2;
        this.destY = destY * CELL_SIZE + CELL_SIZE/2;
        this.vx = 0;
        this.vy = 0;
        this.speed = 0;
        this.targetSpeed = MAX_SPEED;
        this.path = this.calculatePath(startX, startY, destX, destY);
        this.currentSegment = 0;
        this.arrived = false;
    }
    
    calculatePath(sx, sy, dx, dy) {
        const path = [];
        let cx = sx, cy = sy;
        
        while(cx !== dx || cy !== dy) {
            if (cx < dx) {
                path.push({x: cx + 1, y: cy, dir: 'right'});
                cx++;
            } else if (cx > dx) {
                path.push({x: cx - 1, y: cy, dir: 'left'});
                cx--;
            } else if (cy < dy) {
                path.push({x: cx, y: cy + 1, dir: 'down'});
                cy++;
            } else if (cy > dy) {
                path.push({x: cx, y: cy - 1, dir: 'up'});
                cy--;
            }
        }
        return path;
    }
    
    update(vehicles, lights) {
        if (this.arrived) return;
        
        const gridX = Math.floor(this.x / CELL_SIZE);
        const gridY = Math.floor(this.y / CELL_SIZE);
        
        if (this.currentSegment < this.path.length) {
            const target = this.path[this.currentSegment];
            const targetX = target.x * CELL_SIZE + CELL_SIZE/2;
            const targetY = target.y * CELL_SIZE + CELL_SIZE/2;
            
            let dx = targetX - this.x;
            let dy = targetY - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < 2) {
                this.currentSegment++;
            } else {
                dx /= dist;
                dy /= dist;
                
                this.vx = dx * this.speed;
                this.vy = dy * this.speed;
            }
        }
        
        if (Math.abs(this.x - this.destX) < 2 && Math.abs(this.y - this.destY) < 2) {
            this.arrived = true;
            return;
        }
        
        const light = lights.find(l => 
            Math.floor(l.x) === gridX && Math.floor(l.y) === gridY
        );
        
        if (light && light.state === 'red') {
            const distToLight = Math.sqrt(
                Math.pow(this.x - (gridX * CELL_SIZE + CELL_SIZE/2), 2) +
                Math.pow(this.y - (gridY * CELL_SIZE + CELL_SIZE/2), 2)
            );
            if (distToLight < CELL_SIZE * 0.8) {
                this.targetSpeed = 0;
            }
        } else {
            this.targetSpeed = MAX_SPEED;
        }
        
        let closestDist = Infinity;
        for (const v of vehicles) {
            if (v === this || v.arrived) continue;
            const dx = v.x - this.x;
            const dy = v.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < FOLLOW_DISTANCE * 2 && dist < closestDist) {
                const dot = (dx * this.vx + dy * this.vy) / (dist * this.speed || 1);
                if (dot > 0.7) {
                    closestDist = dist;
                    if (dist < FOLLOW_DISTANCE) {
                        this.targetSpeed = Math.max(0, v.speed * 0.8);
                    }
                }
            }
        }
        
        if (this.speed < this.targetSpeed) {
            this.speed += ACCELERATION;
        } else if (this.speed > this.targetSpeed) {
            this.speed *= BRAKE_FACTOR;
        }
        this.speed = Math.max(0, Math.min(MAX_SPEED, this.speed));
        
        this.x += this.vx;
        this.y += this.vy;
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        const angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle);
        ctx.fillStyle = this.color;
        ctx.fillRect(-VEHICLE_SIZE/2, -VEHICLE_SIZE/4, VEHICLE_SIZE, VEHICLE_SIZE/2);
        ctx.fillStyle = '#fff';
        ctx.fillRect(VEHICLE_SIZE/4, -VEHICLE_SIZE/6, VEHICLE_SIZE/4, VEHICLE_SIZE/3);
        ctx.restore();
    }
}

const lights = [];
for (let x = 0; x < GRID_SIZE; x++) {
    for (let y = 0; y < GRID_SIZE; y++) {
        lights.push(new TrafficLight(x, y));
    }
}

const vehicles = [];
for (let i = 0; i < 15; i++) {
    vehicles.push(new Vehicle());
}

function drawRoads() {
    ctx.strokeStyle = '#444';
    ctx.lineWidth = ROAD_WIDTH;
    ctx.lineCap = 'square';
    
    for (let i = 0; i <= GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(CELL_SIZE/2, i * CELL_SIZE + CELL_SIZE/2);
        ctx.lineTo(GRID_SIZE * CELL_SIZE + CELL_SIZE/2, i * CELL_SIZE + CELL_SIZE/2);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE + CELL_SIZE/2, CELL_SIZE/2);
        ctx.lineTo(i * CELL_SIZE + CELL_SIZE/2, GRID_SIZE * CELL_SIZE + CELL_SIZE/2);
        ctx.stroke();
    }
    
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    for (let i = 0; i <= GRID_SIZE; i++) {
        for (let j = 0; j <= GRID_SIZE; j++) {
            ctx.beginPath();
            ctx.moveTo(i * CELL_SIZE + CELL_SIZE/2 - LANE_OFFSET, j * CELL_SIZE + CELL_SIZE/2);
            ctx.lineTo(i * CELL_SIZE + CELL_SIZE/2 + LANE_OFFSET, j * CELL_SIZE + CELL_SIZE/2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(i * CELL_SIZE + CELL_SIZE/2, j * CELL_SIZE + CELL_SIZE/2 - LANE_OFFSET);
            ctx.lineTo(i * CELL_SIZE + CELL_SIZE/2, j * CELL_SIZE + CELL_SIZE/2 + LANE_OFFSET);
            ctx.stroke();
        }
    }
}

function update() {
    for (const light of lights) light.update();
    
    for (const vehicle of vehicles) {
        vehicle.update(vehicles, lights);
    }
    
    for (let i = vehicles.length - 1; i >= 0; i--) {
        if (vehicles[i].arrived) {
            if (Math.random() < 0.02) {
                vehicles[i] = new Vehicle();
            } else if (vehicles.length > 15) {
                vehicles.splice(i, 1);
            }
        }
    }
    
    if (vehicles.length < MAX_VEHICLES && Math.random() < SPAWN_RATE) {
        vehicles.push(new Vehicle());
    }
}

function draw() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    const offsetX = (canvas.width - (GRID_SIZE * CELL_SIZE + CELL_SIZE)) / 2;
    const offsetY = (canvas.height - (GRID_SIZE * CELL_SIZE + CELL_SIZE)) / 2;
    ctx.translate(offsetX, offsetY);
    
    drawRoads();
    for (const light of lights) light.draw();
    for (const vehicle of vehicles) vehicle.draw();
    
    ctx.restore();
}

function animate() {
    update();
    draw();
    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>