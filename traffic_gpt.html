<!doctype html>
<html>
<head>
<meta charset="utf-8">
<style>
html,body{margin:0;padding:0;background:#0b0c10;overflow:hidden}
canvas{display:block;width:250px;height:400px;image-rendering:pixelated}
</style>
</head>
<body>
<canvas id="c" width="250" height="400"></canvas>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const W = canvas.width, H = canvas.height;

  const cols = 10, rows = 10;
  const marginX = 10, marginY = 10;
  const roadW = 10;
  const cellW = (W - 2*marginX - (cols-1)*roadW)/cols;
  const cellH = (H - 2*marginY - (rows-1)*roadW)/rows;
  const blockW = cellW, blockH = cellH;

  const gridW = cols*blockW + (cols-1)*roadW;
  const gridH = rows*blockH + (rows-1)*roadW;
  const ox = (W - gridW)/2;
  const oy = (H - gridH)/2;

  const xLines = new Array(cols).fill(0).map((_,i)=> ox + i*(blockW+roadW) + blockW + (i===cols-1?0:roadW/2));
  const yLines = new Array(rows).fill(0).map((_,j)=> oy + j*(blockH+roadW) + blockH + (j===rows-1?0:roadW/2));

  const laneOffset = roadW*0.18;
  const laneHalf = roadW*0.22;

  function wrapDir(d){ d%=4; if(d<0)d+=4; return d; }
  const DIRS = [
    {dx: 1, dy: 0}, // E
    {dx: 0, dy: 1}, // S
    {dx:-1, dy: 0}, // W
    {dx: 0, dy:-1}  // N
  ];

  function intersectionCenter(i,j){
    return {x:xLines[i], y:yLines[j]};
  }

  function laneXY(i,j,dir){
    const c = intersectionCenter(i,j);
    if(dir===0) return {x:c.x, y:c.y - laneOffset};       // E, upper half of horizontal
    if(dir===2) return {x:c.x, y:c.y + laneOffset};       // W, lower half
    if(dir===1) return {x:c.x + laneOffset, y:c.y};       // S, right half of vertical
    return {x:c.x - laneOffset, y:c.y};                    // N, left half
  }

  const lights = [];
  for(let j=0;j<rows;j++){
    for(let i=0;i<cols;i++){
      const phase0 = ((i*17 + j*31) % 120);
      lights.push({
        i,j,
        t: phase0,
        cycle: 120,
        greenA: 60,
        amber: 6
      });
    }
  }
  function lightAt(i,j){ return lights[j*cols+i]; }
  function isGreen(i,j,dir){
    const L = lightAt(i,j);
    const t = L.t % L.cycle;
    const horiz = (dir===0 || dir===2);
    const g0 = t < L.greenA;
    const inAmber = (!g0) && (t < L.greenA + L.amber);
    if(horiz){
      if(g0) return 1;
      if(inAmber) return 0.3;
      return 0;
    }else{
      if(!g0 && !inAmber) return 1;
      if(inAmber) return 0.3;
      return 0;
    }
  }

  const vehicles = [];
  const maxVehicles = 160;

  function randInt(n){ return (Math.random()*n)|0; }
  function randChoice(a){ return a[(Math.random()*a.length)|0]; }

  function pickRandomEdge(){
    const side = randInt(4);
    if(side===0) return {i:0, j:randInt(rows), dir:0};
    if(side===1) return {i:cols-1, j:randInt(rows), dir:2};
    if(side===2) return {i:randInt(cols), j:0, dir:1};
    return {i:randInt(cols), j:rows-1, dir:3};
  }

  function pickRandomDestDifferent(from){
    let d;
    do{
      d = {i:randInt(cols), j:randInt(rows)};
    }while(d.i===from.i && d.j===from.j);
    return d;
  }

  function nextTurnDir(currDir, i, j, dest){
    const dx = dest.i - i;
    const dy = dest.j - j;
    const opts = [];
    for(let turn=-1; turn<=1; turn++){
      const nd = wrapDir(currDir + turn);
      const ni = i + DIRS[nd].dx;
      const nj = j + DIRS[nd].dy;
      if(ni<0||ni>=cols||nj<0||nj>=rows) continue;
      opts.push(nd);
    }
    if(opts.length===0) return currDir;
    let best = opts[0];
    let bestScore = -1e9;
    for(const nd of opts){
      const ni = i + DIRS[nd].dx;
      const nj = j + DIRS[nd].dy;
      const dist = Math.abs(dest.i - ni) + Math.abs(dest.j - nj);
      const prog = -(dist);
      const align = (Math.abs(dx)>Math.abs(dy))
        ? ((nd===0&&dx>0)||(nd===2&&dx<0) ? 0.4 : 0)
        : ((nd===1&&dy>0)||(nd===3&&dy<0) ? 0.4 : 0);
      const rand = (Math.random()-0.5)*0.15;
      const score = prog + align + rand;
      if(score>bestScore){ bestScore=score; best=nd; }
    }
    return best;
  }

  function spawnVehicle(){
    const s = pickRandomEdge();
    const dest = pickRandomDestDifferent(s);
    const vMax = 22 + Math.random()*10;
    const aMax = 18 + Math.random()*10;
    const bMax = 30 + Math.random()*20;
    const len = 5.5 + Math.random()*2.5;
    const gap = 4 + Math.random()*4;

    vehicles.push({
      i:s.i, j:s.j, dir:s.dir,
      seg: 0,
      dest,
      v: 0,
      vMax,
      aMax,
      bMax,
      len,
      minGap: gap,
      color: `hsl(${(Math.random()*360)|0} 70% 55%)`,
      seed: Math.random()*1000,
      intentDir: s.dir,
      reached:false
    });
  }

  function segLength(i,j,dir){
    const c = intersectionCenter(i,j);
    const ni = i + DIRS[dir].dx;
    const nj = j + DIRS[dir].dy;
    if(ni<0||ni>=cols||nj<0||nj>=rows) return 0;
    const n = intersectionCenter(ni,nj);
    return Math.hypot(n.x - c.x, n.y - c.y);
  }

  function worldPos(i,j,dir,seg){
    const c = laneXY(i,j,dir);
    const ni = i + DIRS[dir].dx;
    const nj = j + DIRS[dir].dy;
    const n = laneXY(ni,nj,dir);
    const dx = n.x - c.x;
    const dy = n.y - c.y;
    return {x: c.x + dx*seg, y: c.y + dy*seg, dx, dy};
  }

  function findLeader(v){
    let best = null;
    let bestDist = 1e9;
    for(const u of vehicles){
      if(u===v) continue;
      if(u.i!==v.i||u.j!==v.j||u.dir!==v.dir) continue;
      const d = u.seg - v.seg;
      if(d>0 && d<bestDist){
        bestDist = d;
        best = u;
      }
    }
    return {leader:best, gap:bestDist};
  }

  function updateLights(dt){
    for(const L of lights){
      L.t = (L.t + dt*30) % L.cycle;
    }
  }

  function stepVehicle(v, dt){
    const L = segLength(v.i,v.j,v.dir);
    if(L<=0){ v.reached=true; return; }

    const traffic = findLeader(v);
    let sLead = 1e9;
    let vLead = 0;
    if(traffic.leader){
      sLead = traffic.gap*L - traffic.leader.len*0.9;
      vLead = traffic.leader.v;
    }

    const center = intersectionCenter(v.i,v.j);
    const ni = v.i + DIRS[v.dir].dx;
    const nj = v.j + DIRS[v.dir].dy;
    const atEdge = (ni<0||ni>=cols||nj<0||nj>=rows);

    let stopDist = 1e9;
    let signalFactor = 1;
    if(!atEdge){
      signalFactor = isGreen(ni,nj,v.dir);
      if(signalFactor<=0){
        stopDist = (1 - v.seg)*L - 2.0;
      }else if(signalFactor<1){
        if(v.v > 10){
          stopDist = (1 - v.seg)*L - 1.0;
        }
      }
    }else{
      stopDist = (1 - v.seg)*L - 2.0;
    }

    const desiredGap = v.minGap + Math.max(0, v.v*0.55) + (v.v*(v.v - vLead)) / (2*Math.sqrt(v.aMax*v.bMax) + 1e-6);
    const sNet = Math.min(sLead, stopDist);
    const freeAcc = v.aMax*(1 - Math.pow(Math.min(1, v.v/(v.vMax+1e-6)), 4));
    const interact = (sNet<1e8) ? v.aMax*(1 - Math.pow(desiredGap/Math.max(0.5,sNet), 2)) : v.aMax;
    let a = Math.min(freeAcc, interact);
    if(signalFactor<=0) a = Math.min(a, -v.bMax*0.9);
    if(stopDist < 8 && v.v>0) a = Math.min(a, -v.bMax*0.7);
    a = Math.max(-v.bMax, Math.min(v.aMax, a));

    v.v += a*dt;
    if(v.v<0) v.v=0;

    const ds = (v.v*dt)/L;
    v.seg += ds;

    while(v.seg >= 1){
      v.seg -= 1;
      if(atEdge){ v.reached=true; break; }
      v.i = ni; v.j = nj;

      if(v.i===v.dest.i && v.j===v.dest.j){
        if(Math.random()<0.4) { v.reached=true; break; }
        v.dest = pickRandomDestDifferent({i:v.i,j:v.j});
      }

      const nd = nextTurnDir(v.dir, v.i, v.j, v.dest);
      v.dir = nd;

      const NL = segLength(v.i,v.j,v.dir);
      if(NL<=0){ v.reached=true; break; }
    }
  }

  function update(dt){
    updateLights(dt);

    const target = maxVehicles;
    const spawnRate = 22;
    const need = Math.max(0, target - vehicles.length);
    const p = Math.min(1, dt*spawnRate) * (need/(target+1));
    if(Math.random() < p) spawnVehicle();
    if(Math.random() < p*0.7) spawnVehicle();

    for(const v of vehicles) stepVehicle(v, dt);
    for(let k=vehicles.length-1;k>=0;k--) if(vehicles[k].reached) vehicles.splice(k,1);
  }

  function draw(){
    ctx.fillStyle = '#0b0c10';
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = '#141a22';
    ctx.fillRect(ox, oy, gridW, gridH);

    ctx.fillStyle = '#242b37';
    for(let i=0;i<cols-1;i++){
      const x = ox + (i+1)*blockW + i*roadW;
      ctx.fillRect(x, oy, roadW, gridH);
    }
    for(let j=0;j<rows-1;j++){
      const y = oy + (j+1)*blockH + j*roadW;
      ctx.fillRect(ox, y, gridW, roadW);
    }

    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4,4]);
    for(let i=0;i<cols-1;i++){
      const x = ox + (i+1)*blockW + i*roadW + roadW/2;
      ctx.beginPath();
      ctx.moveTo(x, oy);
      ctx.lineTo(x, oy+gridH);
      ctx.stroke();
    }
    for(let j=0;j<rows-1;j++){
      const y = oy + (j+1)*blockH + j*roadW + roadW/2;
      ctx.beginPath();
      ctx.moveTo(ox, y);
      ctx.lineTo(ox+gridW, y);
      ctx.stroke();
    }
    ctx.setLineDash([]);

    for(let j=0;j<rows;j++){
      for(let i=0;i<cols;i++){
        const c = intersectionCenter(i,j);
        const L = lightAt(i,j);
        const t = L.t % L.cycle;
        const horizGreen = t < L.greenA;
        const amber = (!horizGreen) && (t < L.greenA + L.amber);
        const hCol = horizGreen ? '#35d07f' : (amber ? '#d0b135' : '#d04a4a');
        const vCol = (!horizGreen && !amber) ? '#35d07f' : (amber ? '#d0b135' : '#d04a4a');

        ctx.fillStyle = hCol;
        ctx.fillRect(c.x-6, c.y-2, 12, 2);
        ctx.fillStyle = vCol;
        ctx.fillRect(c.x-2, c.y-6, 2, 12);
      }
    }

    for(const v of vehicles){
      const p = worldPos(v.i,v.j,v.dir,v.seg);
      const ang = Math.atan2(p.dy, p.dx);
      const w = 3.2, h = v.len*0.55;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(ang);
      ctx.fillStyle = v.color;
      ctx.fillRect(-h*0.5, -w*0.5, h, w);
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      ctx.fillRect(h*0.05, -w*0.35, h*0.35, w*0.7);
      ctx.restore();
    }
  }

  let last = performance.now();
  function loop(t){
    let dt = (t - last)/1000;
    last = t;
    dt = Math.max(0.001, Math.min(0.05, dt));

    const sub = 2;
    const sdt = dt/sub;
    for(let k=0;k<sub;k++) update(sdt);

    draw();
    requestAnimationFrame(loop);
  }

  for(let k=0;k<90;k++) spawnVehicle();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>